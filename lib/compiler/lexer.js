// Generated by CoffeeScript 1.8.0
(function() {
  var ALLOW_HYPHENS_IN_IDENTIFIERS, BOOL, CALLABLE, CODE, COMMENT, COMPARE, COMPOUND_ASSIGN, CONDITIONAL_ASSIGN, CONVERT_HYPHENS_TO_CAMEL_CASE, GLOBAL_IDENTIFIERS, HEREDOC, HEREDOC_ILLEGAL, HEREDOC_INDENT, HEREGEX, HEREGEX_OMIT, IDENTIFIER, IMBA_ALIASES, IMBA_ALIAS_MAP, IMBA_CONTEXTUAL_KEYWORDS, IMBA_KEYWORDS, INDEXABLE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, KEY, KEY_IDENTIFIER, LINE_BREAK, LINE_CONTINUER, LOGIC, Lexer, LexerError, MATH, METHOD_IDENTIFIER, MULTILINER, MULTI_DENT, NOT_REGEX, NOT_SPACED_REGEX, NUMBER, OBJECT_KEY, OBJECT_KEY_ESCAPE, OPERATOR, OP_METHODS, PROPERTY, REGEX, RELATION, RESERVED, Rewriter, SELECTOR, SELECTOR_ATTR, SELECTOR_ATTR_OP, SELECTOR_COMBINATOR, SELECTOR_PART, SELECTOR_PSEUDO_CLASS, SHIFT, SIMPLESTR, STRICT_RESERVED, SYMBOL, StringToCamelCase, TAG, TAG_ATTR, TAG_ID, TAG_TYPE, TRAILING_SPACES, UNARY, WHITESPACE, count, key, last, starts, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ALLOW_HYPHENS_IN_IDENTIFIERS = true;

  CONVERT_HYPHENS_TO_CAMEL_CASE = true;

  StringToCamelCase = function(str) {
    return str;
    return str.replace(/-(\w)/g, function(m, l) {
      return l.toUpperCase();
    });
  };

  _ref = require('./rewriter'), Rewriter = _ref.Rewriter, INVERSES = _ref.INVERSES;

  exports.LexerError = LexerError = (function(_super) {
    __extends(LexerError, _super);

    function LexerError(message, file, line) {
      this.message = message;
      this.file = file;
      this.line = line;
      return this;
    }

    return LexerError;

  })(SyntaxError);

  starts = function(string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  last = function(array, back) {
    return array[array.length - (back || 0) - 1];
  };

  count = function(string, substr) {
    var num, pos;
    num = pos = 0;
    if (!substr.length) {
      return 1 / 0;
    }
    while (pos = 1 + string.indexOf(substr, pos)) {
      num++;
    }
    return num;
  };

  exports.Lexer = Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.tokenize = function(code, opts) {
      var ctx, fn, i, tag, token;
      if (opts == null) {
        opts = {};
      }
      if (WHITESPACE.test(code)) {
        code = "\n" + code;
      }
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      this.code = code;
      this.opts = opts;
      this.line = opts.line || 0;
      this.indent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.ends = [];
      this.tokens = [];
      this.locOffset = opts.loc || 0;
      i = 0;
      while (this.chunk = code.slice(i)) {
        this.loc = this.locOffset + i;
        token = this.tokens[this.tokens.length - 1];
        ctx = this.context();
        fn = null;
        fn = {
          TAG: this.tagContextToken
        }[ctx];
        i += fn && fn.call(this) || this.selectorToken() || this.symbolToken() || this.methodNameToken() || this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.heredocToken() || this.tagToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
      }
      this.closeIndentation();
      if (tag = this.ends.pop()) {
        this.error("missing " + tag);
      }
      if (opts.rewrite === false || opts['no-rewrite']) {
        return this.tokens;
      }
      return (new Rewriter).rewrite(this.tokens);
    };

    Lexer.prototype.context = function(opt) {
      var i, o;
      i = this.ends.length - 1;
      if (opt) {
        o = this.ends["_" + i];
        return o && o[opt];
      } else {
        return this.ends[i];
      }
    };

    Lexer.prototype.scope = function(sym, opts) {
      var len;
      len = this.ends.push(sym);
      if (opts) {
        this.ends["_" + (len - 1)] = opts;
      }
      return sym;
    };

    Lexer.prototype.closeSelector = function() {
      if (this.context() === '%') {
        return this.pair('%');
      }
    };

    Lexer.prototype.openDef = function() {
      return this.ends.push('DEF');
    };

    Lexer.prototype.closeDef = function() {
      var prev;
      if (this.context() === 'DEF') {
        prev = last(this.tokens);
        if (prev[0] === 'DEF_FRAGMENT') {
          true;
        } else {
          this.token('DEF_BODY', 'DEF_BODY');
        }
        return this.pair('DEF');
      }
    };

    Lexer.prototype.tagContextToken = function() {
      var input, match;
      if (match = TAG_TYPE.exec(this.chunk)) {
        this.token('TAG_TYPE', match[0]);
        return match[0].length;
      }
      if (match = TAG_ID.exec(this.chunk)) {
        input = match[0];
        this.token('TAG_ID', input);
        return input.length;
      }
      return 0;
    };

    Lexer.prototype.tagToken = function() {
      var identifier, input, match, type;
      if (!(match = TAG.exec(this.chunk))) {
        return 0;
      }
      input = match[0], type = match[1], identifier = match[2];
      if (type === '<') {
        this.token('TAG_START', '<');
        this.ends.push(INVERSES['TAG_START']);
        if (identifier) {
          if (identifier.substr(0, 1) === '{') {
            return type.length;
          } else {
            this.token('TAG_NAME', input.substr(1));
          }
        }
      }
      return input.length;
    };

    Lexer.prototype.selectorToken = function() {
      var char, id, idx, input, kind, match, string, tag, token, type;
      if (this.context() === '%') {
        char = this.chunk.charAt(0);
        if ((match = SELECTOR_COMBINATOR.exec(this.chunk))) {
          if (this.context('open')) {
            this.pair('%');
            return 0;
          }
          this.token('SELECTOR_COMBINATOR', match[1] || " ");
          return match[0].length;
        } else if (match = SELECTOR_PART.exec(this.chunk)) {
          type = match[1];
          id = match[2];
          tag = (function() {
            switch (type) {
              case '.':
                return 'SELECTOR_CLASS';
              case '#':
                return 'SELECTOR_ID';
              case ':':
                return 'SELECTOR_PSEUDO_CLASS';
              case '::':
                return 'SELECTOR_PSEUDO_CLASS';
              default:
                return 'SELECTOR_TAG';
            }
          })();
          this.token(tag, match[2]);
          return match[0].length;
        } else if (char === '[') {
          this.token('[', '[');
          this.ends.push(']');
          if (match = SELECTOR_ATTR.exec(this.chunk)) {
            this.token('IDENTIFIER', match[1]);
            this.token('SELECTOR_ATTR_OP', match[2]);
            return match[0].length;
          }
          return 1;
        } else if (char === '|') {
          token = this.tokens[this.tokens.length - 1];
          token[0] = 'SELECTOR_NS';
          return 1;
        } else if (char === ',') {
          if (this.context('open')) {
            this.pair('%');
            return 0;
          }
          this.token('SELECTOR_GROUP', ',');
          return 1;
        } else if (char === '*') {
          this.token('UNIVERSAL_SELECTOR', '*');
          return 1;
        } else if (char === ')' || char === '}' || char === ']' || char === '') {
          this.pair('%');
          return 0;
        }
      }
      if (!(match = SELECTOR.exec(this.chunk))) {
        return 0;
      }
      input = match[0], id = match[1], kind = match[2];
      if (kind === '(') {
        this.token('(', '(');
        this.token('SELECTOR_START', id);
        this.ends.push(')');
        this.ends.push('%');
        return id.length + 1;
      } else if (id === '%') {
        if (this.context() === '%') {
          return 1;
        }
        this.token('SELECTOR_START', id);
        this.scope('%', {
          open: true
        });
        return id.length;
      } else {
        return 0;
      }
      if ((id === '%' || id === '$') && (char === '%' || char === '$' || char === '@' || char === '(' || char === '[')) {
        idx = 2;
        if (char === '%' || char === '$' || char === '@') {
          id += char;
          idx = 3;
          char = this.chunk.charAt(2);
        }
        if (char === '(') {
          if (!(string = this.balancedSelector(this.chunk, ')'))) {
            return 0;
          }
          if (0 < string.indexOf('{', 1)) {
            this.token('SELECTOR', id);
            this.interpolateSelector(string.slice(idx, -1));
            return string.length;
          } else {
            this.token('SELECTOR', id);
            this.token('(', '(');
            this.token('STRING', '"' + string.slice(idx, -1) + '"');
            this.token(')', ')');
            return string.length;
          }
        } else if (char === '[') {
          this.token('SELECTOR', id);
          return 1;
        }
      } else {
        return 0;
      }
    };

    Lexer.prototype.methodNameToken = function() {
      var id, innerctx, length, match, outerctx, prev, space, tag, typ, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      outerctx = this.ends[this.ends.length - 2];
      innerctx = this.ends[this.ends.length - 1];
      if (outerctx === '%' && innerctx === ')') {
        if (match = TAG_ATTR.exec(this.chunk)) {
          this.token('TAG_ATTR_SET', match[1]);
          return match[0].length;
        }
      }
      if (!(match = METHOD_IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      prev = last(this.tokens);
      length = match[0].length;
      id = match[0];
      tag = 'IDENTIFIER';
      typ = id.substr(0, 1);
      space = false;
      if (CONVERT_HYPHENS_TO_CAMEL_CASE) {
        id = StringToCamelCase(id);
      }
      if (!(prev && ((_ref1 = prev[0]) === '.' || _ref1 === 'DEF') || ((_ref2 = match[4]) === '!' || _ref2 === '?') || match[5])) {
        return 0;
      }
      if ((_ref3 = id.toUpperCase()) === 'SELF' || _ref3 === 'THIS') {
        return 0;
      }
      if (id === 'super') {
        return 0;
      }
      if (id === 'new') {
        tag = 'NEW';
      }
      if (id === '...' && ((_ref4 = prev[0]) === ',' || _ref4 === '(' || _ref4 === 'CALL_START' || _ref4 === 'BLOCK_PARAM_START' || _ref4 === 'PARAM_START')) {
        return 0;
      }
      if (id === '|') {
        if ((_ref5 = prev[0]) === '(' || _ref5 === 'CALL_START') {
          this.token('DO', 'DO');
          this.ends.push('|');
          this.token('BLOCK_PARAM_START', id);
          return length;
        } else if ((_ref6 = prev[0]) === 'DO' || _ref6 === '{') {
          this.ends.push('|');
          this.token('BLOCK_PARAM_START', id);
          return length;
        } else if (this.ends[this.ends.length - 1] === '|') {
          this.token('BLOCK_PARAM_END', '|');
          this.pair('|');
          return length;
        } else {
          return 0;
        }
      }
      if ((id === '&' || id === '^' || id === '<<' || id === '<<<' || id === '>>') || (id === '|' && this.context() !== '|')) {
        return 0;
      }
      if (__indexOf.call(OP_METHODS, id) >= 0) {
        space = true;
      }
      if (typ === '@') {
        tag = 'IVAR';
        id = new String(id);
        id.wrap = true;
      } else if (typ === '$') {
        tag = 'GVAR';
      } else if (typ === '#') {
        tag = 'TAGID';
      } else if (typ.match(/[A-Z]/) || __indexOf.call(GLOBAL_IDENTIFIERS, id) >= 0) {
        tag = 'CONST';
      }
      if (match[4] || match[5] || __indexOf.call(['eval', 'arguments'].concat(JS_FORBIDDEN), id) >= 0) {
        id = new String(id);
        id.wrap = true;
      }
      if (match[5] && ((_ref7 = prev[0]) === 'IDENTIFIER' || _ref7 === 'CONST' || _ref7 === 'GVAR' || _ref7 === 'CVAR' || _ref7 === 'IVAR' || _ref7 === 'SELF' || _ref7 === 'THIS' || _ref7 === ']' || _ref7 === '}' || _ref7 === ')' || _ref7 === 'NUMBER' || _ref7 === 'STRING' || _ref7 === 'IDREF')) {
        this.token('.', '.');
      }
      this.token(tag, id);
      if (space) {
        last(this.tokens).spaced = true;
      }
      return length;
    };

    Lexer.prototype.inTag = function() {
      var ctx0, ctx1;
      ctx1 = this.ends[this.ends.length - 2];
      ctx0 = this.ends[this.ends.length - 1];
      return ctx0 === 'TAG_END' || (ctx1 === 'TAG_END' && ctx0 === 'OUTDENT');
    };

    Lexer.prototype.identifierToken = function() {
      var addLoc, colon, ctrl, ctx0, ctx1, forcedIdentifier, i, id, inTag, innerctx, input, len, m3, m4, match, prev, tag, typ, _ref1, _ref2;
      ctx1 = this.ends[this.ends.length - 2];
      ctx0 = this.ends[this.ends.length - 1];
      innerctx = this.ends[this.ends.length - 1];
      addLoc = false;
      inTag = ctx0 === 'TAG_END' || (ctx1 === 'TAG_END' && ctx0 === 'OUTDENT');
      if (inTag && (match = TAG_ATTR.exec(this.chunk))) {
        prev = last(this.tokens);
        if (prev[0] !== 'TAG_NAME') {
          if (prev[0] === 'TERMINATOR') {
            true;
          } else {
            this.token(",", ",");
          }
        }
        this.token('TAG_ATTR', match[1]);
        this.token('=', '=');
        return match[0].length;
      }
      if (match = OBJECT_KEY.exec(this.chunk)) {
        id = match[1];
        tag = 'IDENTIFIER';
        this.token(tag, id);
        this.token(':', ':');
        return match[0].length;
      }
      if (!(match = IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      input = match[0], id = match[1], typ = match[2], m3 = match[3], m4 = match[4], colon = match[5];
      if (id === 'own' && this.tag() === 'FOR') {
        this.token('OWN', id);
        return id.length;
      }
      prev = last(this.tokens);
      forcedIdentifier = colon || prev && (((_ref1 = prev[0]) === '.' || _ref1 === '?.' || _ref1 === '::') || !prev.spaced && prev[0] === '@');
      if (id === 'undefined' || id === 'break') {
        forcedIdentifier = false;
      }
      if (colon && prev[0] === '?') {
        forcedIdentifier = false;
      }
      if ((id === 'tag') && this.chunk.match(/^tag\(/)) {
        forcedIdentifier = true;
      }
      if (CONVERT_HYPHENS_TO_CAMEL_CASE) {
        id = StringToCamelCase(id);
      }
      if (id.match(/^\$\d$/)) {
        if (id === '$0') {
          tag = 'ARGUMENTS';
        } else {
          tag = 'ARGVAR';
          id = id.substr(1);
        }
      } else if (typ === '@') {
        tag = 'IVAR';
        id = new String(id);
        id.wrap = true;
      } else if (typ === '#') {
        tag = 'IDENTIFIER';
        this.token('#', '#');
        id = id.substr(1);
      } else if (typ === '@@') {
        id = new String(id);
        id.wrap = true;
        tag = 'CVAR';
      } else if (typ === '$' && !colon) {
        tag = 'GVAR';
      } else if (id.match(/^[A-Z]/) || __indexOf.call(GLOBAL_IDENTIFIERS, id) >= 0) {
        tag = 'CONST';
      } else if (id === 'elif') {
        this.token('ELSE', 'else');
        this.token('IF', 'if');
        return id.length;
      } else {
        tag = 'IDENTIFIER';
      }
      if (!forcedIdentifier && (__indexOf.call(JS_KEYWORDS, id) >= 0 || __indexOf.call(IMBA_KEYWORDS, id) >= 0)) {
        tag = id.toUpperCase();
        addLoc = true;
        if (tag === 'TAG') {
          this.ends.push('TAG');
        }
        if (tag === 'DEF') {
          this.openDef();
        } else if (tag === 'DO') {
          if (this.context() === 'DEF') {
            this.closeDef();
          }
        } else if (tag === 'WHEN' && (_ref2 = this.tag(), __indexOf.call(LINE_BREAK, _ref2) >= 0)) {
          tag = 'LEADING_WHEN';
        } else if (tag === 'FOR') {
          this.seenFor = true;
        } else if (tag === 'UNLESS') {
          tag = 'IF';
        } else if (__indexOf.call(UNARY, tag) >= 0) {
          tag = 'UNARY';
        } else if (__indexOf.call(RELATION, tag) >= 0) {
          if ((tag !== 'INSTANCEOF' && tag !== 'ISA') && this.seenFor) {
            tag = 'FOR' + tag;
            this.seenFor = false;
          } else {
            tag = 'RELATION';
            if (this.value().toString() === '!') {
              this.tokens.pop();
              id = '!' + id;
            }
          }
        }
      }
      if (id === 'super') {
        tag = 'SUPER';
      } else if (__indexOf.call(['eval', 'arguments'].concat(JS_FORBIDDEN), id) >= 0) {
        if (forcedIdentifier) {
          tag = 'IDENTIFIER';
          id = new String(id);
          id.reserved = true;
        } else if (__indexOf.call(RESERVED, id) >= 0) {
          if (__indexOf.call(STRICT_RESERVED, id) >= 0) {
            this.error("reserved word \"" + id + "\"", id.length);
          }
          id = new String(id);
          id.reserved = true;
        }
      }
      if (!forcedIdentifier) {
        if (__indexOf.call(IMBA_ALIASES, id) >= 0) {
          id = IMBA_ALIAS_MAP[id];
        }
        tag = (function() {
          switch (id) {
            case '√':
              return 'SQRT';
            case 'ƒ':
              return 'FUNC';
            case '!':
              return 'UNARY';
            case '==':
            case '!=':
            case '===':
            case '!==':
              return 'COMPARE';
            case '&&':
            case '||':
              return 'LOGIC';
            case '∪':
            case '∩':
              return 'MATH';
            case 'true':
            case 'false':
            case 'null':
            case 'nil':
            case 'undefined':
              return 'BOOL';
            case 'break':
            case 'continue':
            case 'debugger':
            case 'arguments':
              return id.toUpperCase();
            default:
              return tag;
          }
        })();
      }
      prev = last(this.tokens);
      len = input.length;
      if (tag === 'CLASS' || tag === 'DEF' || tag === 'TAG' || tag === 'VAR') {
        i = this.tokens.length;
        while (i) {
          prev = this.tokens[--i];
          ctrl = prev && ("" + prev[1]);
          if (__indexOf.call(IMBA_CONTEXTUAL_KEYWORDS, ctrl) >= 0) {
            prev[0] = ctrl.toUpperCase();
          } else {
            break;
          }
        }
      }
      if (tag === 'IDENTIFIER') {
        if (prev && prev[0] === 'CATCH') {
          tag = 'CATCH_VAR';
        }
        this.token(tag, id, len);
      } else if (addLoc) {
        this.token(tag, id, len, true);
      } else {
        this.token(tag, id);
      }
      if (colon) {
        this.token(':', ':');
      }
      return len;
    };

    Lexer.prototype.numberToken = function() {
      var binaryLiteral, lexedLength, match, number, prev, _ref1;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      lexedLength = number.length;
      if (binaryLiteral = /0b([01]+)/.exec(number)) {
        number = (parseInt(binaryLiteral[1], 2)).toString();
      }
      prev = last(this.tokens);
      if (match[0][0] === '.' && prev && !prev.spaced && ((_ref1 = prev[0]) === 'IDENTIFIER' || _ref1 === ')' || _ref1 === '}' || _ref1 === ']' || _ref1 === 'NUMBER')) {
        this.token(".", ".");
        number = number.substr(1);
      }
      this.token('NUMBER', number);
      return lexedLength;
    };

    Lexer.prototype.symbolToken = function() {
      var match, prev, symbol, _ref1;
      if (!(match = SYMBOL.exec(this.chunk))) {
        return 0;
      }
      symbol = match[0].substr(1);
      prev = last(this.tokens);
      if (prev && !prev.spaced && ((_ref1 = prev[0]) !== '(' && _ref1 !== '{' && _ref1 !== '[' && _ref1 !== '.' && _ref1 !== 'RAW_INDEX_START' && _ref1 !== 'CALL_START' && _ref1 !== 'INDEX_START' && _ref1 !== ',' && _ref1 !== '=' && _ref1 !== 'INDENT' && _ref1 !== 'TERMINATOR')) {
        this.token('.', '.');
        symbol = symbol.split(/[\:\\\/]/)[0];
        this.token('SYMBOL', symbol);
        return symbol.length + 1;
      } else {
        this.token('SYMBOL', symbol);
        return match[0].length;
      }
    };

    Lexer.prototype.stringToken = function() {
      var match, string;
      switch (this.chunk.charAt(0)) {
        case "'":
          if (!(match = SIMPLESTR.exec(this.chunk))) {
            return 0;
          }
          this.token('STRING', (string = match[0]).replace(MULTILINER, '\\\n'));
          break;
        case '"':
          if (!(string = this.balancedString(this.chunk, '"'))) {
            return 0;
          }
          if (string.indexOf('{') >= 0) {
            this.interpolateString(string.slice(1, -1));
          } else {
            this.token('STRING', this.escapeLines(string));
          }
          break;
        default:
          return 0;
      }
      this.line += count(string, '\n');
      return string.length;
    };

    Lexer.prototype.heredocToken = function() {
      var doc, heredoc, match, quote;
      if (!(match = HEREDOC.exec(this.chunk))) {
        return 0;
      }
      heredoc = match[0];
      quote = heredoc.charAt(0);
      doc = this.sanitizeHeredoc(match[2], {
        quote: quote,
        indent: null
      });
      if (quote === '"' && 0 <= doc.indexOf('{')) {
        this.interpolateString(doc, {
          heredoc: true
        });
      } else {
        this.token('STRING', this.makeString(doc, quote, true));
      }
      this.line += count(heredoc, '\n');
      return heredoc.length;
    };

    Lexer.prototype.commentToken = function() {
      var comment, here, match;
      if (!(match = this.chunk.match(COMMENT))) {
        return 0;
      }
      comment = match[0], here = match[1];
      if (here) {
        this.token('HERECOMMENT', this.sanitizeHeredoc(here, {
          herecomment: true,
          indent: Array(this.indent + 1).join(' ')
        }));
        this.token('TERMINATOR', '\n');
      }
      this.line += count(comment, '\n');
      return comment.length;
    };

    Lexer.prototype.jsToken = function() {
      var match, script;
      if (!(this.chunk.charAt(0) === '`' && (match = JSTOKEN.exec(this.chunk)))) {
        return 0;
      }
      this.token('JS', (script = match[0]).slice(1, -1));
      return script.length;
    };

    Lexer.prototype.regexToken = function() {
      var flags, length, match, prev, regex, _ref1, _ref2;
      if (this.chunk.charAt(0) !== '/') {
        return 0;
      }
      if (match = HEREGEX.exec(this.chunk)) {
        length = this.heregexToken(match);
        this.line += count(match[0], '\n');
        return length;
      }
      prev = last(this.tokens);
      if (prev && (_ref1 = prev[0], __indexOf.call((prev.spaced ? NOT_REGEX : NOT_SPACED_REGEX), _ref1) >= 0)) {
        return 0;
      }
      if (!(match = REGEX.exec(this.chunk))) {
        return 0;
      }
      _ref2 = match, match = _ref2[0], regex = _ref2[1], flags = _ref2[2];
      if (regex.slice(0, 2) === '/*') {
        this.error('regular expressions cannot begin with `*`');
      }
      if (regex === '//') {
        regex = '/(?:)/';
      }
      this.token('REGEX', "" + regex + flags);
      return match.length;
    };

    Lexer.prototype.heregexToken = function(match) {
      var body, flags, heregex, re, tag, tokens, value, _i, _len, _ref1, _ref2, _ref3, _ref4;
      heregex = match[0], body = match[1], flags = match[2];
      if (0 > body.indexOf('#{')) {
        re = body.replace(HEREGEX_OMIT, '').replace(/\//g, '\\/');
        if (re.match(/^\*/)) {
          this.error('regular expressions cannot begin with `*`');
        }
        this.token('REGEX', "/" + (re || '(?:)') + "/" + flags);
        return heregex.length;
      }
      this.token('IDENTIFIER', 'RegExp');
      this.tokens.push(['CALL_START', '(']);
      tokens = [];
      _ref1 = this.interpolateString(body, {
        regex: true
      });
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], tag = _ref2[0], value = _ref2[1];
        if (tag === 'TOKENS') {
          tokens.push.apply(tokens, value);
        } else {
          if (!(value = value.replace(HEREGEX_OMIT, ''))) {
            continue;
          }
          value = value.replace(/\\/g, '\\\\');
          tokens.push(['STRING', this.makeString(value, '"', true)]);
        }
        tokens.push(['+', '+']);
      }
      tokens.pop();
      if (((_ref3 = tokens[0]) != null ? _ref3[0] : void 0) !== 'STRING') {
        this.tokens.push(['STRING', '""'], ['+', '+']);
      }
      (_ref4 = this.tokens).push.apply(_ref4, tokens);
      if (flags) {
        this.tokens.push([',', ','], ['STRING', '"' + flags + '"']);
      }
      this.token(')', ')');
      return heregex.length;
    };

    Lexer.prototype.lineToken = function() {
      var diff, indent, match, noNewlines, prev, size;
      if (!(match = MULTI_DENT.exec(this.chunk))) {
        return 0;
      }
      if (this.ends[this.ends.length - 1] === '%') {
        this.pair('%');
      }
      indent = match[0];
      this.line += count(indent, '\n');
      this.seenFor = false;
      prev = last(this.tokens, 1);
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      if (size - this.indebt === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken(indent);
        }
        return indent.length;
      }
      if (size > this.indent) {
        if (noNewlines) {
          this.indebt = size - this.indent;
          this.suppressNewlines();
          return indent.length;
        }
        if (this.inTag()) {
          console.log("indent inside tag?!?");
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.closeDef();
        this.token('INDENT', diff);
        this.indents.push(diff);
        this.ends.push('OUTDENT');
        this.outdebt = this.indebt = 0;
      } else {
        this.indebt = 0;
        this.outdentToken(this.indent - size, noNewlines);
      }
      this.indent = size;
      return indent.length;
    };

    Lexer.prototype.outdentToken = function(moveOut, noNewlines) {
      var ctx, dent, len;
      while (moveOut > 0) {
        len = this.indents.length - 1;
        if (this.indents[len] === void 0) {
          moveOut = 0;
        } else if (this.indents[len] === this.outdebt) {
          moveOut -= this.outdebt;
          this.outdebt = 0;
        } else if (this.indents[len] < this.outdebt) {
          this.outdebt -= this.indents[len];
          moveOut -= this.indents[len];
        } else {
          dent = this.indents.pop() - this.outdebt;
          moveOut -= dent;
          this.outdebt = 0;
          this.pair('OUTDENT');
          this.token('OUTDENT', dent);
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {
        this.token('TERMINATOR', '\n');
      }
      ctx = this.context();
      if (ctx === '%' || ctx === 'TAG') {
        this.pair(ctx);
      }
      this.closeDef();
      return this;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      prev = last(this.tokens);
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.newlineToken = function(chunk) {
      var arr, ctx, i, lines, prev;
      while (this.value() === ';') {
        this.tokens.pop();
      }
      prev = last(this.tokens);
      arr = ['\\n'];
      lines = count(chunk, '\n');
      i = 0;
      while ((++i) !== lines) {
        arr.push('\\n');
      }
      if (this.tag() !== 'TERMINATOR') {
        this.token('TERMINATOR', arr.join(""));
      }
      ctx = this.context();
      if (ctx === '%' || ctx === 'TAG') {
        this.pair(ctx);
      }
      this.closeDef();
      return this;
    };

    Lexer.prototype.suppressNewlines = function() {
      if (this.value() === '\\') {
        this.tokens.pop();
      }
      return this;
    };

    Lexer.prototype.literalToken = function() {
      var end1, end2, inTag, length, match, prev, tag, value, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      end1 = this.ends[this.ends.length - 1];
      end2 = this.ends[this.ends.length - 2];
      inTag = end1 === 'TAG_END' || end1 === 'OUTDENT' && end2 === 'TAG_END';
      tag = value;
      prev = last(this.tokens);
      length = value.length;
      if (value === '=' && prev) {
        if (!prev[1].reserved && (_ref1 = prev[1], __indexOf.call(JS_FORBIDDEN, _ref1) >= 0)) {
          this.error("reserved word \"" + (this.value()) + "\" can't be assigned");
        }
        if ((_ref2 = prev[1]) === '||' || _ref2 === '&&') {
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          return value.length;
        }
      }
      if (value === ';') {
        this.seenFor = false;
        tag = 'TERMINATOR';
      } else if (value === '(' && inTag && prev[0] !== '=' && prev.spaced) {
        this.token(',', ',');
      } else if (value === '->' && inTag) {
        tag = 'TAG_END';
        this.pair('TAG_END');
      } else if (value === '/>' && inTag) {
        tag = 'TAG_END';
        this.pair('TAG_END');
      } else if (value === '>' && inTag) {
        tag = 'TAG_END';
        this.pair('TAG_END');
      } else if (value === '>' && this.context() === 'DEF') {
        tag = 'DEF_FRAGMENT';
      } else if (value === 'TERMINATOR' && end1 === '%') {
        this.closeSelector();
      } else if (value === 'TERMINATOR' && end1 === 'DEF') {
        this.closeDef();
      } else if (value === '&' && this.context() === 'DEF') {
        tag = 'BLOCK_ARG';
      } else if (value === '*' && this.chunk.charAt(1).match(/[A-Za-z\_\@\[]/) && (prev.spaced || ((_ref3 = prev[1]) === ',' || _ref3 === '(' || _ref3 === '[' || _ref3 === '{' || _ref3 === '|' || _ref3 === '\n' || _ref3 === '\t'))) {
        tag = "SPLAT";
      } else if (value === '√') {
        tag = 'SQRT';
      } else if (value === 'ƒ') {
        tag = 'FUNC';
      } else if (__indexOf.call(MATH, value) >= 0) {
        tag = 'MATH';
      } else if (__indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (__indexOf.call(CONDITIONAL_ASSIGN, value) >= 0) {
        tag = 'CONDITIONAL_ASSIGN';
      } else if (__indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
        tag = 'COMPOUND_ASSIGN';
      } else if (__indexOf.call(UNARY, value) >= 0) {
        tag = 'UNARY';
      } else if (__indexOf.call(SHIFT, value) >= 0) {
        tag = 'SHIFT';
      } else if (__indexOf.call(LOGIC, value) >= 0) {
        tag = 'LOGIC';
      } else if (prev && !prev.spaced) {
        if (value === '(' && end1 === '%') {
          tag = 'TAG_ATTRS_START';
        } else if (value === '(' && (_ref4 = prev[0], __indexOf.call(CALLABLE, _ref4) >= 0)) {
          tag = 'CALL_START';
        } else if (value === '[' && (_ref5 = prev[0], __indexOf.call(INDEXABLE, _ref5) >= 0)) {
          tag = 'INDEX_START';
          switch (prev[0]) {
            case '?':
              prev[0] = 'INDEX_SOAK';
          }
        } else if (value === '{' && (_ref6 = prev[0], __indexOf.call(INDEXABLE, _ref6) >= 0)) {
          tag = 'RAW_INDEX_START';
        }
      }
      switch (value) {
        case '(':
        case '{':
        case '[':
          this.ends.push(INVERSES[value]);
          break;
        case ')':
        case '}':
        case ']':
          this.pair(value);
      }
      this.token(tag, value);
      return value.length;
    };

    Lexer.prototype.sanitizeHeredoc = function(doc, options) {
      var attempt, herecomment, indent, match, _ref1;
      indent = options.indent, herecomment = options.herecomment;
      if (herecomment) {
        if (HEREDOC_ILLEGAL.test(doc)) {
          this.error("block comment cannot contain \"*/\", starting");
        }
        if (doc.indexOf('\n') <= 0) {
          return doc;
        }
      } else {
        while (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[1];
          if (indent === null || (0 < (_ref1 = attempt.length) && _ref1 < indent.length)) {
            indent = attempt;
          }
        }
      }
      if (indent) {
        doc = doc.replace(RegExp("\\n" + indent, "g"), '\n');
      }
      if (!herecomment) {
        doc = doc.replace(/^\n/, '');
      }
      return doc;
    };

    Lexer.prototype.tagParameters = function() {
      var i, stack, tok, tokens;
      if (this.tag() !== ')') {
        return this;
      }
      stack = [];
      tokens = this.tokens;
      i = tokens.length;
      tokens[--i][0] = 'PARAM_END';
      while (tok = tokens[--i]) {
        switch (tok[0]) {
          case ')':
            stack.push(tok);
            break;
          case '(':
          case 'CALL_START':
            if (stack.length) {
              stack.pop();
            } else if (tok[0] === '(') {
              tok[0] = 'PARAM_START';
              return this;
            } else {
              return this;
            }
        }
      }
      return this;
    };

    Lexer.prototype.closeIndentation = function() {
      this.closeDef();
      this.closeSelector();
      return this.outdentToken(this.indent);
    };

    Lexer.prototype.balancedString = function(str, end) {
      var i, letter, match, prev, stack, v;
      stack = [end];
      i = 0;
      while (i < (str.length - 1)) {
        i++;
        switch (letter = str.charAt(i)) {
          case '\\':
            i++;
            continue;
          case end:
            stack.pop();
            if (!stack.length) {
              v = str.slice(0, i + 1);
              return v;
            }
            end = stack[stack.length - 1];
            continue;
        }
        if (end === '}' && (letter === '"' || letter === "'")) {
          stack.push(end = letter);
        } else if (end === '}' && letter === '/' && (match = HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i)))) {
          i += match[0].length - 1;
        } else if (end === '}' && letter === '{') {
          stack.push(end = '}');
        } else if (end === '"' && letter === '{') {
          stack.push(end = '}');
        }
        prev = letter;
      }
      return this.error("missing " + (stack.pop()) + ", starting");
    };

    Lexer.prototype.interpolateString = function(str, options) {
      var expr, heredoc, i, inner, interpolated, len, letter, nested, pi, prefix, regex, tag, tokens, value, _i, _len, _ref1, _ref2, _ref3;
      if (options == null) {
        options = {};
      }
      heredoc = options.heredoc, regex = options.regex;
      prefix = options.prefix;
      tokens = [];
      pi = 0;
      i = -1;
      while (letter = str.charAt(i += 1)) {
        if (letter === '\\') {
          i += 1;
          continue;
        }
        if (!(str.charAt(i) === '{' && (expr = this.balancedString(str.slice(i), '}')))) {
          continue;
        }
        if (pi < i) {
          tokens.push(['NEOSTRING', str.slice(pi, i)]);
        }
        inner = expr.slice(1, -1);
        if (inner.length) {
          nested = new Lexer().tokenize(inner, {
            line: this.line,
            rewrite: false,
            loc: this.loc + i + 2
          });
          nested.pop();
          if (((_ref1 = nested[0]) != null ? _ref1[0] : void 0) === 'TERMINATOR') {
            nested.shift();
          }
          if (len = nested.length) {
            if (len > 1) {
              nested.unshift(['(', '(']);
              nested.push([')', ')']);
            }
            tokens.push(['TOKENS', nested]);
          }
        }
        i += expr.length - 1;
        pi = i + 1;
      }
      if ((i > pi && pi < str.length)) {
        tokens.push(['NEOSTRING', str.slice(pi)]);
      }
      if (regex) {
        return tokens;
      }
      if (!tokens.length) {
        return this.token('STRING', '""');
      }
      if (tokens[0][0] !== 'NEOSTRING') {
        tokens.unshift(['', '']);
      }
      if (interpolated = tokens.length > 1) {
        this.token('(', '(');
      }
      for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
        _ref2 = tokens[i], tag = _ref2[0], value = _ref2[1];
        if (i) {
          this.token('+', '+');
        }
        if (tag === 'TOKENS') {
          (_ref3 = this.tokens).push.apply(_ref3, value);
        } else {
          this.token('STRING', this.makeString(value, '"', heredoc));
        }
      }
      if (interpolated) {
        this.token(')', ')');
      }
      return tokens;
    };

    Lexer.prototype.balancedSelector = function(str, end) {
      var i, letter, prev, stack, _i, _ref1;
      stack = [end];
      for (i = _i = 1, _ref1 = str.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
        switch (letter = str.charAt(i)) {
          case '\\':
            i++;
            continue;
          case end:
            stack.pop();
            if (!stack.length) {
              return str.slice(0, i + 1);
            }
            end = stack[stack.length - 1];
            continue;
        }
        if (end === '}' && letter === [')']) {
          stack.push(end = letter);
        } else if (end === '}' && letter === '{') {
          stack.push(end = '}');
        } else if (end === ')' && letter === '{') {
          stack.push(end = '}');
        }
        prev = letter;
      }
      return this.error("missing " + (stack.pop()) + ", starting");
    };

    Lexer.prototype.interpolateSelector = function(str, options) {
      var expr, heredoc, i, inner, interpolated, len, letter, nested, pi, prefix, regex, tag, tokens, value, _i, _len, _ref1, _ref2, _ref3;
      if (options == null) {
        options = {};
      }
      heredoc = options.heredoc, regex = options.regex;
      prefix = options.prefix;
      tokens = [];
      pi = 0;
      i = -1;
      while (letter = str.charAt(i += 1)) {
        if (!(letter === '{' && (expr = this.balancedSelector(str.slice(i), '}')))) {
          continue;
        }
        if (pi < i) {
          tokens.push(['NEOSTRING', str.slice(pi, i)]);
        }
        inner = expr.slice(1, -1);
        if (inner.length) {
          nested = new Lexer().tokenize(inner, {
            line: this.line,
            rewrite: false
          });
          nested.pop();
          if (((_ref1 = nested[0]) != null ? _ref1[0] : void 0) === 'TERMINATOR') {
            nested.shift();
          }
          if (len = nested.length) {
            if (len > 1) {
              nested.unshift(['(', '(']);
              nested.push([')', ')']);
            }
            tokens.push(['TOKENS', nested]);
          }
        }
        i += expr.length - 1;
        pi = i + 1;
      }
      if ((i > pi && pi < str.length)) {
        tokens.push(['NEOSTRING', str.slice(pi)]);
      }
      if (regex) {
        return tokens;
      }
      if (!tokens.length) {
        return this.token('STRING', '""');
      }
      if (tokens[0][0] !== 'NEOSTRING') {
        tokens.unshift(['', '']);
      }
      if (interpolated = tokens.length > 1) {
        this.token('(', '(');
      }
      for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
        _ref2 = tokens[i], tag = _ref2[0], value = _ref2[1];
        if (i) {
          this.token(',', ',');
        }
        if (tag === 'TOKENS') {
          (_ref3 = this.tokens).push.apply(_ref3, value);
        } else {
          this.token('STRING', this.makeString(value, '"', heredoc));
        }
      }
      if (interpolated) {
        this.token(')', ')');
      }
      return tokens;
    };

    Lexer.prototype.pair = function(tag) {
      var size, wanted;
      if (tag !== (wanted = last(this.ends))) {
        if ('OUTDENT' !== wanted) {
          this.error("unmatched " + tag);
        }
        this.indent -= size = last(this.indents);
        this.outdentToken(size, true);
        return this.pair(tag);
      }
      if (tag === '%') {
        this.token('SELECTOR_END', '%');
      }
      this.ends["_" + (this.ends.length - 1)] = void 0;
      return this.ends.pop();
    };

    Lexer.prototype.token = function(tag, value, len, addLoc) {
      var loc;
      loc = {
        first_line: this.line,
        first_column: 2,
        last_line: this.line,
        last_column: 2,
        range: [this.loc, 1000]
      };
      if (len && addLoc) {
        true;
      } else if (len) {
        if (typeof value === 'string') {
          value = new String(value);
        }
        value._region = [this.loc, this.loc + len];
      }
      if (tag === 'INDENT' || tag === 'OUTDENT') {
        value = new Number(value);
        value._region = [this.loc, this.loc];
      }
      return this.tokens.push([tag, value, loc]);
    };

    Lexer.prototype.tag = function(index, tag) {
      var tok;
      return (tok = last(this.tokens, index)) && (tag ? tok[0] = tag : tok[0]);
    };

    Lexer.prototype.value = function(index, val) {
      var tok;
      return (tok = last(this.tokens, index)) && (val ? tok[1] = val : tok[1]);
    };

    Lexer.prototype.unfinished = function() {
      var _ref1;
      if (LINE_CONTINUER.test(this.chunk)) {
        return true;
      }
      return (_ref1 = this.tag()) === '\\' || _ref1 === '.' || _ref1 === '?.' || _ref1 === 'UNARY' || _ref1 === 'MATH' || _ref1 === '+' || _ref1 === '-' || _ref1 === 'SHIFT' || _ref1 === 'RELATION' || _ref1 === 'COMPARE' || _ref1 === 'LOGIC' || _ref1 === 'COMPOUND_ASSIGN' || _ref1 === 'THROW' || _ref1 === 'EXTENDS' || _ref1 === 'CONDITIONAL_ASSIGN';
    };

    Lexer.prototype.escapeLines = function(str, heredoc) {
      return str.replace(MULTILINER, heredoc ? '\\n' : '');
    };

    Lexer.prototype.makeString = function(body, quote, heredoc) {
      if (!body) {
        return quote + quote;
      }
      body = body.replace(/\\([\s\S])/g, function(match, contents) {
        if (contents === '\n' || contents === quote) {
          return contents;
        } else {
          return match;
        }
      });
      body = body.replace(RegExp("" + quote, "g"), '\\$&');
      return quote + this.escapeLines(body, heredoc) + quote;
    };

    Lexer.prototype.error = function(message, len) {
      var err, msg;
      msg = "" + message + " on line " + this.line;
      if (len) {
        msg += " [" + this.loc + ":" + (this.loc + len) + "]";
      }
      err = new SyntaxError(msg);
      err.line = this.line;
      throw err;
    };

    return Lexer;

  })();

  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'throw', 'break', 'continue', 'debugger', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'module', 'return'];

  IMBA_KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when', 'def', 'tag', 'do', 'elif', 'begin', 'prop', 'var', 'let', 'self', 'await'];

  IMBA_CONTEXTUAL_KEYWORDS = ['extend', 'static', 'local', 'export', 'global'];

  IMBA_ALIAS_MAP = {
    and: '&&',
    or: '||',
    is: '==',
    isnt: '!=',
    not: '!',
    yes: 'true',
    no: 'false',
    isa: 'instanceof',
    "case": 'switch',
    nil: 'null'
  };

  IMBA_ALIASES = (function() {
    var _results;
    _results = [];
    for (key in IMBA_ALIAS_MAP) {
      _results.push(key);
    }
    return _results;
  })();

  IMBA_KEYWORDS = IMBA_KEYWORDS.concat(IMBA_ALIASES);

  RESERVED = ['case', 'default', 'function', 'void', 'with', 'const', 'enum', 'native'];

  STRICT_RESERVED = ['case', 'function', 'void', 'const'];

  JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED);

  exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(IMBA_KEYWORDS);

  KEY = /^((([A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)|\[\])=?)\:\s/;

  KEY_IDENTIFIER = /^((([\$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([\=\?\!]?))|(<=>|~=|~|\|(?!\|)))/;

  METHOD_IDENTIFIER = /^((([\x23]?[\$A-Za-z_\x7f-\uffff][$\-\w\x7f-\uffff]*)([\=\?\!]?))|(<=>|\|(?![\|=])))/;

  IDENTIFIER = /^((\$|@@|@|\#)[A-Za-z_\-\x7f-\uffff][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*|[$A-Za-z_][$\w\x7f-\uffff]*(\-[$\w\x7f-\uffff]+)*)([^\n\S]*:(?![\*\=:$\w\x7f-\uffff]))?/;

  OBJECT_KEY = /^((\$|@@|@|)[$A-Za-z_\x7f-\uffff\-][$\w\x7f-\uffff\-]*)([^\n\S\s]*:(?![\*\=:$\w\x7f-\uffff]))/;

  OBJECT_KEY_ESCAPE = /[\-\@\$]/;

  PROPERTY = /^((set|get|on)\s+)?([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff\:]*)([^\n\S]*:\s)/;

  TAG = /^(\<|%)(?=[A-Za-z\#\.\{\@])/;

  TAG_TYPE = /^(\w[\w\d]*:)?(\w[\w\d]*)(-[\w\d]+)*/;

  TAG_ID = /^#((\w[\w\d]*)(-[\w\d]+)*)/;

  TAG_ATTR = /^([\.]?[\w\_]+([\-\:][\w]+)*)(\s)*\=/;

  SELECTOR = /^([%\$]{1,2})([\(\w\#\.\[])/;

  SELECTOR_PART = /^(\#|\.|:|::)?([\w]+(\-[\w]+)*)/;

  SELECTOR_COMBINATOR = /^ (\+|\>|\~)*\s*(?=[\w\.\#\:\{\*\[])/;

  SELECTOR_PSEUDO_CLASS = /^(::?)([\w]+(\-[\w]+)*)/;

  SELECTOR_ATTR_OP = /^(\$=|\~=|\^=|\*=|\|=|=|\!=)/;

  SELECTOR_ATTR = /^\[([\w\_\-]+)(\$=|\~=|\^=|\*=|\|=|=|\!=)/;

  SYMBOL = /^\:((([\*\@$\w\x7f-\uffff]+)+([\-\/\\\:][\w\x7f-\uffff]+)*[!\?\=]?)|==|\<=\>|\[\]|\[\]\=|\*|[\/,\\])/;

  NUMBER = /^0x[\da-f]+|^0b[01]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

  HEREDOC = /^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/;

  OPERATOR = /^(?:[-=]=>|===|!==|[-+*\/%<>&|^!?=]=|=<|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\.{2,3}|\*(?=[a-zA-Z\_]))/;

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*(#\s.*|#\s*$))+/;

  CODE = /^[-=]=>/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  SIMPLESTR = /^'[^\\']*(?:\\.[^\\']*)*'/;

  JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

  REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;

  HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;

  HEREGEX_OMIT = /\s+(?:#.*)?/g;

  MULTILINER = /\n/g;

  HEREDOC_INDENT = /\n+([^\n\S]*)/g;

  HEREDOC_ILLEGAL = /\*\//;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

  TRAILING_SPACES = /\s+$/;

  CONDITIONAL_ASSIGN = [];

  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '=<'];

  UNARY = ['!', '~', 'NEW', 'TYPEOF', 'DELETE'];

  LOGIC = ['&&', '||', '&', '|', '^'];

  SHIFT = ['<<', '>>', '>>>'];

  COMPARE = ['===', '!==', '==', '!=', '<', '>', '<=', '>=', '===', '!=='];

  OP_METHODS = ['<=>', '<<', '..'];

  MATH = ['*', '/', '%', '∪', '∩', '√'];

  RELATION = ['IN', 'OF', 'INSTANCEOF', 'ISA'];

  BOOL = ['TRUE', 'FALSE', 'NULL', 'UNDEFINED'];

  NOT_REGEX = ['NUMBER', 'REGEX', 'BOOL', '++', '--', ']'];

  NOT_SPACED_REGEX = NOT_REGEX.concat(')', '}', 'THIS', 'SELF', 'IDENTIFIER', 'STRING');

  CALLABLE = ['IDENTIFIER', 'STRING', 'REGEX', ')', ']', 'THIS', 'SUPER', 'TAG_END', 'IVAR', 'GVAR', 'SELF', 'CONST', 'NEW', 'ARGVAR', 'SYMBOL', 'RETURN'];

  INDEXABLE = CALLABLE.concat('NUMBER', 'BOOL', 'TAG_SELECTOR', 'IDREF', 'ARGUMENTS', '}');

  GLOBAL_IDENTIFIERS = ['global', 'exports', 'require'];

  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];

}).call(this);
