# imba$inlineHelpers=1
# imba$v2=0
# TODO Create Expression - make all expressions inherit from these?

var helpers = require './helpers'
var constants = require './constants'
var csscompiler = require './css'

import ImbaParseError,ImbaTraverseError from './errors'
import Token from './token'
import SourceMap from './sourcemap'

import StyleRule,StyleTheme,Color from './styler.imba'
import parseAsset from './assets.imba'

var TAG_NAMES = constants.TAG_NAMES

var TAG_TYPES = {}
var TAG_ATTRS = {}

TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br
 button canvas caption cite code col colgroup data datalist dd del details dfn
 div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6
 head header hr html i iframe img input ins kbd keygen label legend li link
 main map mark menu menuitem meta meter nav noscript object ol optgroup option
 output p param pre progress q rp rt ruby s samp script section select small
 source span strong strike style sub summary sup table tbody td textarea tfoot th
 thead time title tr track u ul var video wbr".split(" ")

TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polyline radialGradient rect stop svg text tspan".split(" ")

TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async
 autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked
 className cols colSpan content contentEditable contextMenu controls coords
 crossOrigin data dateTime defer dir disabled download draggable encType form
 formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon
 id label lang list loop max maxLength mediaGroup method min multiple muted
 name noValidate pattern placeholder poster preload radioGroup readOnly rel
 required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop
 seamless selected shape size span spellCheck src srcDoc srcSet start step
 style tabIndex target title type useMap value width wmode"

TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform
 gradientUnits markerEnd markerMid markerStart offset opacity
 patternContentUnits patternUnits points preserveAspectRatio r rx ry
 spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap
 strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y"

var CUSTOM_EVENTS = {
	intersect: yes
	selection: yes
	resize: yes
}

export var AST = {}

var TREE_TYPE =
	DYNAMIC: 1
	STATIC: 2
	SINGLE: 3
	OPTLOOP: 4
	LOOP: 5

export var F = 
	TAG_INITED: 2 ** 0 
	TAG_BUILT: 2 ** 1 # available
	TAG_CUSTOM: 2 ** 2 # available
	TAG_AWAKENED: 2 ** 3
	TAG_MOUNTED: 2 ** 4
	TAG_SCHEDULE: 2 ** 5 # available
	TAG_SCHEDULED: 2 ** 6
	TAG_FIRST_CHILD: 2 ** 7
	TAG_LAST_CHILD: 2 ** 8
	TAG_HAS_DYNAMIC_FLAGS: 2 ** 9
	TAG_HAS_BRANCHES: 2 ** 10
	TAG_HAS_LOOPS: 2 ** 11
	TAG_HAS_DYNAMIC_CHILDREN: 2 ** 12
	TAG_IN_BRANCH: 2 ** 13
	TAG_BIND_MODEL: 2 ** 14
	TAG_INDEXED: 2 ** 15 # not used
	TAG_KEYED: 2 ** 16 # not used
	
	
	EL_INITED: 2 ** 0
	EL_HYDRATED: 2 ** 1
	EL_DEHYDRATED: 2 ** 2
	EL_AWAKENED: 2 ** 3
	EL_MOUNTING: 2 ** 4
	EL_MOUNTED: 2 ** 5
	EL_SCHEDULE: 2 ** 6 # available
	EL_SCHEDULED: 2 ** 7
	EL_RENDERING: 2 ** 8
	EL_RENDERED: 2 ** 9

	# render marks
	DIFF_BUILT: 2 ** 0
	DIFF_FLAGS: 2 ** 1
	DIFF_ATTRS: 2 ** 2
	DIFF_CHILDREN: 2 ** 3


# Helpers for operators
export var OP = do |op, l, r|
	var o = String(op)
	if o == '-' and !r and (l isa Num or l isa NumWithUnit)
		l.negate
		return l
	elif o == '+' and !r and (l isa Num or l isa NumWithUnit)
		return l

	switch o
		when '.'
			r = Identifier.new(r) if r isa String
			# r = r.value if r isa VarOrAccess
			
			if r.@value and r.@value.@value == 'new'
				return New.new(l).set(keyword: r)
				
			Access.new(op,l,r)
		when '='
			Assign.new(op,l,r)
		
		when '~='
			return OP('&=',l,OP('~',r))

		when '?=','||=','&&=','??='
			ConditionalAssign.new(op,l,r)
		when '+=','-=','*=','/=','^=','%=','**='
			CompoundAssign.new(op,l,r)

		when '?.'
			if r isa VarOrAccess
				r = r.value
			# depends on the right side - this is wrong
			PropertyAccess.new(op,l,r)

		when 'instanceof','isa'
			InstanceOf.new(op,l,r)
		when 'in'
			In.new(op,l,r)
		when 'typeof'
			TypeOf.new(op,l,r)
		when 'delete'
			Delete.new(op,l,r)
		when '--','++','!','âˆš','not','!!'
			UnaryOp.new(op,l,r)
		when '>','<','>=','<=','==','===','!=','!=='
			ComparisonOp.new(op,l,r)
		when '..','...'
			Range.new(op,l,r)
		else
			Op.new(op,l,r)

var PATHIFY = do |val|
	if val isa TagAttrValue
		val = val.value

	if val isa ArgList
		val = val.values[0]
		
	while val isa Parens
		val = val.value
	
	if val isa VarOrAccess
		val = val.@variable or val.value
	# console.log "TagData value {val}"

	if val isa Access
		let left = val.left
		let right = val.right isa Index ? val.right.value : val.right

		if left isa VarOrAccess
			left = left.@variable or left.value

		if right isa VarOrAccess
			right = right.@variable or right.value
		
		if val isa IvarAccess
			left ||= val.scope__.context

		if right isa Identifier
			right = helpers.singlequote(String(right.js))
			right = Str.new(right)
		
		return [left,right]

	return val

var OPTS = {}
var ROOT = null

export var NODES = []

var C = do |node,opts|
	(typeof node == 'string' or typeof node == 'number') ? node : node.c(opts)

var M = do |val,mark,o|
	if mark == undefined
		mark = val

	if mark and mark:startLoc
		val = C(val,o)
		let ref = STACK.incr('sourcePair')
		let start = mark.startLoc
		let end = mark.endLoc
		let m0 = ''
		let m1 = ''

		if start == 0 or start > 0
			m0 = end >= start ? "/*%{start}|{ref}$*/" : "/*%{start}$*/"
			
		if end == 0 or end > 0
			m1 = start >= 0 ? "/*%{end}|{ref}$*/" : "/*%{end}$*/"
		return m0 + val + m1
	return C(val,o)

var MSTART = do |*params|
	for item in params
		if item isa Number
			return item
		if item and item:startLoc isa Function
			return item.startLoc
	return null

var MEND = do |*params|
	for item in params
		if item isa Number
			return item
		if item and item:endLoc isa Function
			return item.endLoc
	return null

var TYP = do |item,format|
	let typ = item.@options and item.@options:datatype
	typ ||= item:datatype isa Function and item.datatype

	if typ
		if format == 'jsdoc'
			"/** @type \{{M(typ,typ)}\} */"
		else
			":{M(typ,typ)}"
	else
		""

var LIT = do |val|
	RawScript.new(val)

var SYM = do |val|
	Symbol.new(val)

var KEY = do |val|
	val = val.value if val isa Token
	if val isa String
		if val.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/)
			val = Identifier.new(val)
		else
			val = Str.new(helpers.singlequote(String(val)))
	return val



var STR = do |val|
	return val if val isa Str
	return Str.new(helpers.singlequote(String(val)))

var IF = do |cond,body,alt,o={}|
	var node = If.new(cond,body,o)
	node.addElse(alt) if alt
	node

var NODIFY = do |val|
	if val == null
		return Nil.new
	elif val == false
		return False.new
	elif val == true
		return True.new
	elif val isa String
		return STR(val)
	elif val isa Number
		return Num.new(val)
	else
		return val

var FN = do |pars,body,scope|
	let fn = Func.new(pars,body)
	if scope
		fn.@scope.@systemscope = scope
	return fn

var METH = do |pars,body|
	ClosedFunc.new(pars,body)

var CALL = do |callee,pars = []|
	# possibly return instead(!)
	Call.new(callee,pars)

var GET = do |left,right| OP('.',left,right)

var CALLSELF = do |name,pars = []|
	var ref = Identifier.new(name)
	Call.new(OP('.',SELF,ref),pars)

var BLOCK = do
	Block.wrap([]:slice.call(arguments))

var WHILE = do |test,code|
	While.new(test).addBody(code)



export var SPLAT = do |value|
	Splat.new(value)
	# if value isa Assign
	#	value.left = Splat.new(value.left)
	#	return value
	# else
	#	Splat.new(value)

var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/
var RESERVED_TEST = /^(default|char|for)$/

# captures error from parser
export def parseError str, o
	# find nearest token
	var err

	if o:lexer
		var token = o:lexer:yytext
		# console.log o:lexer:pos,token.@loc
		err = ImbaParseError.new({message: str},{
			pos: o:lexer:pos
			tokens: o:lexer:tokens
			token: o:lexer:yytext
			meta: o
		})

		throw err

		# should find the closest token with actual position
		# str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
	var e = Error.new(str)
	e:lexer = o:lexer
	e:options = o
	throw e

def AST.c obj
	typeof obj == 'string' ? obj : obj.c

def AST.compileRaw item
	let o = ''
	if item isa Array
		o = '['
		for v in item
			o += AST.compileRaw(v) + ','
		o = o.slice(0,-1) + ']'

	elif item isa Object
		o = '{'
		for own k,v of item
			# maybe quote?
			o =+ "{k}:{AST.compileRaw(v)},"
		o = o.slice(0,-1) + '}'
	else
		o = JSON.stringify(item)
	return o

def AST.blk obj
	obj isa Array ? Block.wrap(obj) : obj

def AST.sym obj
	# console.log "sym {obj}"
	helpers.symbolize(String(obj))

def AST.cary ary
	ary.map do |v|
		if typeof v == 'string'
			return v
		elif v && v:c
			return v.c
		else
			console.warn 'could not compile',v
			return String(v)

def AST.dump obj, key
	if obj isa Array
		obj.map do |v| v && v:dump ? v.dump(key) : v
	elif obj and obj:dump
		obj.dump

def AST.compact ary
	if ary isa ListNode
		return ary.compact


	ary.filter do |v| v != undefined && v != null

def AST.reduce res,ary
	for v in ary
		v isa Array ? AST.reduce(res,v) : res.push(v)
	return

def AST.flatten ary, compact = no
	var out = []
	for v in ary
		v isa Array ? AST.reduce(out,v) : out.push(v)
	return out

def AST.loc item
	if !item
		[0,0]
	elif item isa Token
		item.region
	elif item isa Node
		item.loc
	
def AST.parse str, opts = {}
	var indent = str.match(/\t+/)[0]
	# really? Require the compiler, not this
	Imbac.parse(str,opts)

def AST.inline str, opts = {}
	parse(str,opts).body

def AST.node typ, pars
	if typ == 'call'
		if pars[0].c == 'return'
			pars[0] = 'tata'
		Call.new(pars[0],pars[1],pars[2])

def AST.escapeComments str
	return '' unless str
	return str


var shortRefCache = []

def AST.counterToShortRef nr
	var base = "A".charCodeAt(0)

	while shortRefCache:length <= nr
		var num = shortRefCache:length + 1
		var str = ""

		while true
			num -= 1
			str = String.fromCharCode(base + (num % 26)) + str
			num = Math.floor(num / 26)
			break unless num > 0

		shortRefCache.push(str.toLowerCase())

	return shortRefCache[nr]

def AST.truthy node

	if node isa True
		return true

	if node isa False
		return false

	if node:isTruthy
		return node.isTruthy

	return undefined

export class Indentation

	prop open
	prop close

	def initialize a,b
		@open = a
		@close = b
		self

	def isGenerated
		@open and @open:generated

	def aloc
		@open and @open.@loc or 0

	def bloc
		@close and @close.@loc or 0

	def startLoc
		aloc

	def endLoc
		bloc


	def wrap str
		var om = @open and @open.@meta
		var pre = om and om:pre or ''
		var post = om and om:post or ''
		var esc = AST:escapeComments
		var out = @close

		# the first newline should not be indented?

		str = post.replace(/^\n/,'') + str

		str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n")

		str = pre + '\n' + str
		str += out.c if out isa Terminator
		str = str + '\n' unless str[str:length - 1] == '\n'

		return str

var INDENT = Indentation.new({},{})

class Stash

	def initialize
		@entities = []

	def add item
		@entities.unshift(item)
		self

	def pluck item
		var match = null
		for entity,i in @entities
			if entity == item or entity isa item
				match = entity
				@entities.splice(i,1)
				return match
		return null


export class Stack

	prop loglevel
	prop nodes
	prop scopes
	prop root
	prop state
	prop semanticTokens
	prop theme

	def initialize
		reset

	def reset
		@nodes    = []
		@scoping  = []
		@scopes   = []
		@stash    = Stash.new(self)
		@loglevel = 3
		@counter  = 0
		@counters = {}
		@options = {}
		@state = {}
		@tag = null
		@sourceId = null
		@semanticTokens = []
		@symbols = {}
		@theme = null
		self
	
	def registerSemanticToken token, kind, modifiers
		if token isa Node
			kind ||= token.@variable
			token = token.@value
			
		if kind isa Variable
			token.@kind = kind.type
			token.@level = kind.scope.level
			token.@scope = kind.scope.kind
		else
			token.@kind = kind
		@semanticTokens.push(token)
		
		
	def incr name
		@counters[name] ||= 0
		@counters[name] += 1

	def decr name
		@counters[name] ||= 0
		@counters[name] -= 1

	def generateId ns = 'oid'
		AST.counterToShortRef(STACK.incr(ns))
		
	def getSymbol ref
		ref ||= incr('symbols')
		# Belongs in root
		@symbols[ref] ||= @root.declare(ref,LIT('Symbol()'),system: yes).resolve.c

	def getAsset name
		let assets = config:assets 
		assets ? assets[name] : null

	def sourceId
		return @sourceId if @sourceId
		let src = sourcePath
		let cwd = self.cwd
		# relativize the cwd thing
		# TODO rename+document this option. sourceBase or sourceRoot?
		if @options:path and cwd
			src = @options:path.relative(cwd,src)
		@sourceId = helpers.identifierForPath(src)
		return @sourceId

	def theme
		@theme = config:theme or StyleTheme.new(config:styles)

	def stash
		@stash

	def set obj
		@options ||= {}
		for own k,v of obj
			@options[k] = v
		self

	# get and set
	def option key, val
		if val != undefined
			@options ||= {}
			@options[key] = val
			return self

		@options && @options[key]

	def platform
		@options:platform

	def format
		@options:format

	def sourcePath
		@options:sourcePath

	def config
		@options:config or {}
	
	def cwd
		config && config:cwd
	
	def tsc
		platform == 'tsc' or @options:tsc

	def isWeb
		platform == 'browser' or platform == 'web'
	
	def isWorker
		platform == 'worker'
	
	def isNode
		platform == 'node'

	def cjs
		format == 'cjs' or (!format and isNode)
	
	# The format defaults to esm
	def esm
		!cjs

	def env key
		var val = @options["ENV_{key}"]
		return val if val != undefined
		
			
		if F[key] !== undefined
			return F[key]
		
		var lowercased = key.toLowerCase
		
		if @options[lowercased] != undefined
			return @options[lowercased]
			
		if key == 'WEB' or key == 'BROWSER'
			return isWeb
		elif key == 'NODE'
			return isNode
		elif key == 'WORKER' or key == 'WEBWORKER'
			return isWorker

		if var e = @options:env
			if e.hasOwnProperty(key)
				return e[key]
			elif e.hasOwnProperty(key.toLowerCase)
				return e[key.toLowerCase]

		if $node$ and typeof process != 'undefined' and process:env
			val = process:env[key.toUpperCase]
			if val != undefined
				return val
			return null

		return undefined	


	def addScope scope
		@scopes.push(scope)
		self

	def traverse node
		self

	def push node
		@nodes.push(node)
		# not sure if we have already defined a scope?
		self

	def pop node
		@nodes.pop # (node)
		self

	def parent
		@nodes[@nodes:length - 2]

	def current
		@nodes[@nodes:length - 1]

	def up test
		test ||= do |v| !(v isa VarOrAccess)
			
		if typeof test == 'number'
			return @nodes[@nodes:length - (1 + test)]

		var i = @nodes:length - 2

		if test:prototype isa Node
			while i >= 0
				var node = @nodes[i--]
				return node if node isa test
			return null

		while i >= 0
			var node = @nodes[i]
			return node if test(node)
			i -= 1
		return null

	def relative node, offset = 0
		var idx = @nodes.indexOf(node)
		idx >= 0 ? @nodes[idx + offset] : null

	def scope lvl = 0
		var i = @nodes:length - 1 - lvl
		while i >= 0
			var node = @nodes[i]
			return node.@scope if node.@scope
			i -= 1
		return null

	def scopes
		# include deeper scopes as well?
		var scopes = []
		var i = @nodes:length - 1
		while i >= 0
			var node = @nodes[i]
			scopes.push(node.@scope) if node.@scope
			i -= 1
		return scopes

	def method
		up(MethodDeclaration)

	def block
		up(Block)

	def blockpart
		let i = @nodes:length - 1
		while i
			if @nodes[i - 1] isa Block
				return @nodes[i]
			i--
		return

	def isExpression
		var i = @nodes:length - 1
		while i >= 0
			var node = @nodes[i]
			# why are we not using isExpression here as well?
			if node isa Code or node isa Loop
				return false
			if node.isExpression
				return true
			# probably not the right test - need to be more explicit
			i -= 1
		return false

	def toString
		"Stack({@nodes.join(" -> ")})"

	def isAnalyzing
		@analyzing

	def scoping
		@nodes.filter(|n| n.@scope ).map(|n| n.@scope )
		
	def currentRegion
		let l = @nodes:length
		let node = @nodes[--l]
		node and [node.startLoc,node.endLoc]

# Lots of globals -- really need to deal with one stack per file / context
export var STACK = Stack.new

# use a bitmask for these

export class Node

	prop o
	prop options
	prop traversed

	def safechain
		no

	def oid
		@oid ||= STACK.generateId('')
		
	def osym ns = ''
		STACK.getSymbol(oid + ns)

	def symbolRef name
		STACK.root.symbolRef(name)

	# get global symbol with name
	def gsym name
		scope__.root.symbolRef(name)
		
	def sourceId
		STACK.sourceId

	# shorthand for the self context for a node
	def slf
		scope__.context

	def p
		# allow controlling this from CLI
		if STACK.loglevel > 0
			console.log(*arguments)
		self

	def typeName
		self:constructor:name

	def namepath
		typeName

	def initialize
		setup
		self

	def setup
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@value = null
		self

	def setStartLoc loc
		@startLoc = loc
		return self

	def setEndLoc loc
		@endLoc = loc
		return self

	def setRegion loc
		if loc isa Node
			loc = loc.region

		if loc isa Array
			@startLoc = loc[0]
			@endLoc = loc[1]
		return self

	def setEnds start,end
		if end and end:endLoc
			@endLoc = end.endLoc
		if start and start:startLoc
			@startLoc = start.startLoc
		self

	def startLoc
		@startLoc

	def endLoc
		@endLoc

	def set obj
		@options ||= {}
		for own k,v of obj
			@options[k] = v
		self

	# get and set
	def option key, val
		if val != undefined
			@options ||= {}
			@options[key] = val
			return self

		@options && @options[key]

	def o
		@options ||= {}

	def keyword
		@keyword or (@options and @options:keyword)
		
	def datatype
		@options ? @options:datatype : null

	def configure obj
		set(obj)

	def region
		[0,0]

	def loc
		[0,0]

	def token
		null

	def compile
		self

	def visit
		self

	def stack
		STACK

	def isString
		no

	def isPrimitive deep
		no

	def isReserved
		no

	# should rather do traversals
	# o = {}, up, key, index
	def traverse o
		if @traversed
			return self
		# NODES.push(self)
		@traversed = yes
		let prev
		if o
			prev = STACK.state
			STACK.state = o
		STACK.push self
		visit(STACK,STACK.state)
		STACK.pop self
		if o
			STACK.state = prev
		return self

	def inspect
		{type: self:constructor.toString}

	def js o
		"NODE"

	def toString
		"{self:constructor:name}"

	# swallow might be better name
	def consume node
		if node isa TagLike
			return node.register(self)

		if node isa PushAssign
			node.register(self)
			return PushAssign.new(node.op,node.left,self)

		if node isa Assign
			# node.right = self
			return OP(node.op,node.left,self)
		elif node isa VarDeclaration
			return OP('=',node.left,self)
		elif node isa Op
			return OP(node.op,node.left,self)
		elif node isa Return
			return Return.new(self)
		return self

	def toExpression
		@expression = true
		self

	def forceExpression
		@expression = true
		self

	def isExpressable
		true

	def isExpression
		@expression || false

	def hasSideEffects
		true

	def isUsed
		true

	def shouldParenthesize
		false

	def shouldParenthesizeInTernary
		yes

	def block
		Block.wrap([self])

	def node
		self

	def scope__
		STACK.scope

	def up
		STACK.parent

	def util
		Util

	def receiver
		self

	def indented a,b

		if a isa Indentation
			@indentation = a
			return self

		# this is a _BIG_ hack
		if b isa Array
			add(b[0])
			b = b[1]

		# if indent and indent.match(/\:/)
		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		self

	def prebreak term = '\n'
		self

	def invert
		return OP('!',self)

	def cache o = {}
		@cache = o
		o:var = (o:scope or scope__).temporary(self,o)
		o:lookups = 0
		self

	def cachevar
		@cache && @cache:var

	def decache
		if @cache
			cachevar.free
			@cache = null
		self

	# the "name-suggestion" for nodes if they need to be cached
	def alias
		null

	def warn text, opts = {}
		opts:message = text
		opts:loc ||= loc
		scope__.root.warn opts
		self

	def c o
		var s = STACK
		var ch = @cache
		return c_cached(ch) if ch and ch:cached

		s.push(self)
		forceExpression if o && o:expression

		if o and o:indent
			@indentation ||= INDENT
		
		var out = js(s,o)

		var paren = shouldParenthesize

		s.pop(self)

		if out == undefined
			return out

		if var indent = @indentation
			out = indent.wrap(out,o)
			self

		# should move this somewhere else really
		out = "({out})" if paren
		if (o and o:braces) or (@options and @options:braces)
			if indent
				out = '{' + out + '}'
			else
				out = '{ ' + out + ' }'

		if ch = @cache
			out = "{ch:var.c} = {out}" unless ch:manual
			var par = s.current
			par = par.node if par isa ValueNode
			out = '(' + out + ')' if par isa Access || par isa Op # others? #
			ch:cached = yes

		if OPTS:sourceMap and (!o or o:mark !== false)
			out = M(out,self)
		return out

	def c_cached cache
		cache:lookups++
		cache:var.free if cache:uses == cache:lookups
		return cache:var.c # recompile every time??

export class ValueNode < Node

	prop value

	def startLoc
		@value?.startLoc

	def endLoc
		@value?.endLoc

	def initialize value
		setup
		@value = load(value)

	def load value
		value

	def js o
		typeof @value == 'string' ? @value : @value.c

	def visit

		@value.traverse if @value isa Node #  && @value:traverse
		self

	def region
		[@value.@loc,@value.@loc + @value.@len]

export class ExpressionNode < ValueNode

export class AssertionNode < ValueNode
	def js o
		let op = @value
		let out = []

		if op isa Op and !(op isa Access)
			let l = op.left
			let r = op.right

			out.push(l.cache.c(o))
			out.push(helpers.singlequote(op.@op))
			out.push(r.cache.c(o))
			out = ["imba.$a=[{out.join(',')}]"]
			out.push(op.c(o))
			# op.cache
			# out.push('imba.$asrt=undefined')
			# out.push(op.c(o))
		else
			out.push('imba.$a=null')
			out.push(op.c(o))
		return '(' + out.join(',') + ")" # ,{op.c(o)})
		# "('assert',{super})"

export class Statement < ValueNode

	def isExpressable
		return no


export class Meta < ValueNode

	def isPrimitive deep
		yes

export class Comment < Meta

	def visit
		if @value.type == 'HERECOMMENT'
			let raw = @value.@value
			let line = raw.slice(0,raw.indexOf('\n')).trim

			if let m = line.match(/^(css|less|stylus|sass|scss)( scoped)?/)
				var style = {
					content: raw.slice(raw.indexOf('\n'))
					scoped: !!m[2]
					type: m[1]
					attrs: {}
				}
				# compile style directly here?
				scope__.root.styles.push(style)
				stack.set(hasScopedStyles: yes) if m[2]

		if var block = up
			var idx = block.indexOf(self) + 1
			idx += 1 if block.index(idx) isa Terminator
			if var next = block.index(idx)
				next.@desc = self

		self

	def toDoc
		helpers.normalizeIndentation("" + @value.@value)

	def toJSON
		helpers.normalizeIndentation("" + @value.@value)

	def c o
		return "" if STACK.option(:comments) == false

		var v = @value.@value
		if o and o:expression or v.match(/\n/) or @value.type == 'HERECOMMENT' # multiline?
			var out = v.replace(/\*\//g, '\\*\\/').replace(/\/\*/g, '\\/\\*')
			"/*{out}*/"
		elif v.match(/\@(type|param)/)
			"/** {v} */"
		else
			"// {v}"

export class Terminator < Meta

	def initialize v
		@value = v
		self

	def traverse
		self

	def loc
		[@value.@loc,@value.@loc + @value.@value:length]

	def startLoc
		@value:startLoc ? @value.startLoc : -1

	def endLoc
		@value.@value ? (startLoc + @value.@value:length) : -1

	def c
		let val = @value.c
		if STACK.option(:comments) == false
			val = val.replace(/\/\/.*$/gm,'')

		if STACK.tsc and (val:length > 1 or @first)
			return M(val.replace(/^[\t ]+/gm,''),self)

		return val.replace(/^[\t ]+/gm,'')

export class Newline < Terminator

	def initialize v
		@traversed = no
		@value = v or '\n'

	def c
		@value
		# M(@value,@value)


# weird place?
export class Index < ValueNode

	def cache o = {}
		@value.cache(o)

	def js o
		@value.c

export class ListNode < Node

	prop nodes

	def initialize list
		setup
		@nodes = load(list or [])
		@indentation = null

	# PERF acces @nodes directly?
	def list
		@nodes

	def compact
		@nodes = AST.compact(@nodes)
		self

	def load list
		list

	def concat other
		# need to store indented content as well?
		@nodes = nodes.concat(other isa Array ? other : other.nodes)
		self

	def swap item, other
		var idx = indexOf(item)
		nodes[idx] = other if idx >= 0
		self

	def push item
		@nodes.push(item)
		self

	def pop
		var end = @nodes.pop
		return end

	def add item, o
		let idx = null
		if o and o:before
			idx = @nodes.indexOf(o:before)
			idx = null if idx == -1
		elif o and o:after
			idx = @nodes.indexOf(o:after) + 1
			idx = null if idx == 0
			if idx >= 1
				while @nodes[idx] isa Meta
					idx++
		elif o isa Number
			idx = o

		if idx !== null
			item isa Array ? @nodes.splice(idx,0,*item) : @nodes.splice(idx,0,item)
		else
			item isa Array ? @nodes.push(*item) : @nodes.push(item)
		self

	def unshift item, br
		@nodes.unshift(BR) if br
		@nodes.unshift(item)
		self

	# test
	def slice a, b
		self:constructor.new(@nodes.slice(a,b))

	def break br, pre = no
		br = Terminator.new(br) if typeof br == 'string'
		pre ? unshift(br) : push(br)
		self

	def some cb
		for node in @nodes
			return yes if cb(node)
		return no

	def every cb
		for node in @nodes
			return no unless cb(node)
		return yes
	
	# filtered list of items
	def values
		@nodes.filter do |item| !(item isa Meta)

	def filter cb
		@nodes.filter(cb)

	def pluck cb
		var item = filter(cb)[0]
		remove(item) if item
		return item

	def indexOf item
		@nodes.indexOf(item)

	def index i
		@nodes[i]

	def remove item
		var idx = @nodes.indexOf(item)
		@nodes.splice(idx, 1) if idx >= 0
		self

	def removeAt idx
		var item = @nodes[idx]
		@nodes.splice(idx, 1) if idx >= 0
		return item


	def replace original, replacement
		var idx = @nodes.indexOf(original)
		if idx >= 0
			if replacement isa Array
				@nodes.splice(idx,1,*replacement)
			else
				@nodes[idx] = replacement
		self

	def first
		@nodes[0]

	def last
		var i = @nodes:length
		while i
			i = i - 1
			var v = @nodes[i]
			return v unless v isa Meta
		return null

	def map fn
		@nodes.map(fn)

	def forEach fn
		@nodes.forEach(fn)

	def remap fn
		@nodes = map(fn)
		self

	def count
		@nodes:length

	def len
		@nodes:length

	def realCount
		var k = 0
		for node in @nodes
			k++ if node and !(node isa Meta)
		return k

	def isEmpty
		realCount == 0

	def visit
		let items = @nodes
		let i = 0

		while i < items:length
			let item = items[i]
			if item:traverse
				let res = item.traverse
				if res != item
					if res isa Array
						items.splice(i,1,*res)
						continue
			i++
		self

	def isExpressable
		for node in nodes
			return no if node and !node.isExpressable

		return yes

	def toArray
		@nodes

	def delimiter
		@delimiter or ","

	def js o, nodes: @nodes
		var delim = ','
		var express = delim != ';'
		var last = last

		var i = 0
		var l = nodes:length
		var str = ""

		for arg in nodes
			var part = typeof arg == 'string' ? arg : (arg ? arg.c(expression: express) : '')

			str += part
			str += delim if part and (!express or arg != last) and !(arg isa Meta)

		return str

	def indented a,b
		if a isa Indentation
			@indentation = a
			return self

		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		self

	def endLoc
		if @endLoc
			return @endLoc

		var i = @nodes:length
		let last = @nodes[i - 1]
		last?.endLoc


export class ArgList < ListNode

	def consume node
		if node isa TagLike
			@nodes = @nodes.map do |child|
				if !(child isa Meta) # and !(child isa Assign)
					child.consume(node)
				else
					child
			return self
		super

export class AssignList < ArgList

	def concat other
		if @nodes:length == 0 and other isa AssignList
			return other
		else
			super(other)
		# need to store indented content as well?
		# @nodes = nodes.concat(other isa Array ? other : other.nodes)
		self


export class Block < ListNode

	prop head

	def initialize list
		setup
		@nodes = list or []
		@head = null
		@indentation = null
		
	def startLoc
		@indentation ? @indentation.startLoc : super
	
	def endLoc
		@indentation ? @indentation.endLoc : super

	def self.wrap ary
		unless ary isa Array
			throw SyntaxError.new("what")
		ary:length == 1 && ary[0] isa Block ? ary[0] : Block.new(ary)

	def visit stack
		@scope.visit if @scope

		if stack and stack.@tag
			@tag = stack.@tag

		for node,i in @nodes
			# allow replacing blocks?
			node and node.traverse
		
		self

	def block
		self
		
	def collectDecorators
		if let decorators = @decorators
			@decorators = null
			return decorators

	def loc
		# rather indents, no?
		if var opt = option(:ends)
			var a = opt[0].loc
			var b = opt[1].loc

			p "no loc for {opt[0]}" unless a
			p "no loc for {opt[1]}" unless b

			return [a[0],b[1]]

		if var ind = @indentation
			if ind.aloc != -1
				return [ind.aloc,ind.bloc]

		let a = @nodes[0]
		let b = @nodes[@nodes:length - 1]

		[a and a.loc[0] or 0,b and b.loc[1] or 0]

	# go through children and unwrap inner nodes
	def unwrap
		var ary = []
		for node,i in nodes
			if node isa Block
				ary:push.apply(ary,node.unwrap)
			else
				ary.push(node)
		return ary

	# This is just to work as an inplace replacement of nodes.coffee
	# After things are working okay we'll do bigger refactorings
	def compile o = {}
		var root = Root.new(self,o)
		root.compile(o)


	# Not sure if we should create a separate block?
	def analyze o = {}
		self

	def cpart node
		return "" if node === BR0
		var out = typeof node == 'string' ? node : (node ? node.c : "")
		return "" if out == null or out == undefined or out == ""

		if out isa Array
			var str = ""
			var l = out:length
			var i = 0
			while i < l
				str += cpart(out[i++])
			return str

		var hasSemiColon = SEMICOLON_TEST.test(out)
		out += delimiter unless hasSemiColon or node isa Meta
		return out

	def delimiter
		@delimiter == undefined ? ';' : @delimiter

	def js o, opts
		var ast = @nodes
		var l = ast:length
		# really?
		var express = isExpression or o.isExpression or (option(:express) and isExpressable)
		return '' if ast:length == 0 and (!@head or @head:length == 0)

		if express
			return super(o,nodes: ast)

		var str = ""
		let empty = no
		for v in ast
			let vs = cpart(v)
			# FIXME windows?
			if vs[0] == '\n' and (/^\n+$/).test(vs)
				continue if empty
				empty = yes
			elif vs
				empty = no
			# console.log 'add item?',JSON.stringify(vs)
			str += vs

		# now add the head items as well
		if @head and @head:length > 0
			var prefix = ""
			for v in @head
				var hv = cpart(v)
				prefix += hv + '\n' if hv
			str = prefix + str
			
		if option(:strict)
			str = cpart('"use strict";\n') + str

		return str


	# Should this create the function as well?
	def defers original, replacement
		var idx = @nodes.indexOf(original)
		@nodes[idx] = replacement if idx >= 0
		var rest = @nodes.splice(idx + 1)
		return rest

	def expressions
		var expressions = []
		for node in nodes
			expressions.push(node) unless node isa Terminator
		return expressions


	def consume node
		if node isa TagLike
			let real = expressions

			@nodes = @nodes.map do |child|
				if child in real and !(child isa Assign)
					child.consume(node)
				else
					child
			return self

		# can also return super if it is expressable, but should we really?
		if var before = last
			var after = before.consume(node)
			if after != before
				if after isa Block
					after = after.nodes

				replace(before,after)

		return self


	def isExpressable
		return no unless @nodes.every(|v| v.isExpressable )
		return yes

	def isExpression

		option(:express) || @expression

	def shouldParenthesizeInTernary
		if count == 1
			return first.shouldParenthesizeInTernary

		yes
		
	def indented a,b
		super
		if a isa Token and a.@type == 'INDENT'
			if let post = (a.@meta and a.@meta:post)
				let br = Token.new('TERMINATOR',post)
				@nodes.unshift(Terminator.new(br))
				a.@meta:post = ''
		return self

class ClassInitBlock < Block

class InstanceInitBlock < Block

export class ClassField < Node
	prop name

	def initialize name
		super
		@name = name

	def visit
		@decorators = up?.collectDecorators
		@classdecl = STACK.up(ClassDeclaration)
		@name.traverse if @name and @name:traverse

		if value
			value.@scope = @vscope = FieldScope.new(value)
			value.@scope.@parent = scope__
			value.traverse

		self
	

	def value
		option(:value)

	def target
		option(:static) ? LIT('this') : LIT('this.prototype')

	def storageKey
		@storageKey ||= STR(name.c + '$$')

	def storageMap
		@storageMap ||= scope__.root.declare(null,LIT('new WeakMap()'))

	def isPlain
		!@decorators and (!@value or @value.isPrimitive)

	def isLazy
		no
		
	def hasStaticInits
		isStatic or @decorators
		
	def hasConstructorInits
		!isStatic

	def isStatic
		option(:static)
		
	def datatype
		option(:datatype)

	def loc
		[@name.@loc,@name.region[1]]

	def c
		return if option(:struct)
		
		let up = STACK.current
		let out
		if up isa ClassBody
			# return if isPlain
			let prefix = isStatic ? "{M('static',option(:static))} " : ''
			let name = name isa IdentifierExpression ? name.asObjectKey : name.c

			if STACK.tsc
				out = "{prefix}{M(name,@name)}" # the value scope?
				out += " = {value.c}" if value
				if datatype
					if let typ = TYP(self,'jsdoc')
						out = "{typ}\n{out}"

			elif self isa ClassAttribute or (@decorators && @decorators:length > 0)
				let setter = "{prefix}set {name}{self.setter.c(keyword: '')}"
				let getter = "{prefix}get {name}{self.getter.c(keyword: '')}"
				let delim = (@classdecl && @classdecl.isExtension ? ',\n' : '\n')
				out = "{setter}{delim}{getter}"
			
		elif !STACK.tsc
			if isStatic and up isa ClassInitBlock
				if @vscope
					if let fn = STACK.up(Func)
						@vscope.mergeScopeInto(fn.@scope)
				out = OP('=',OP('.',THIS,name),value or UNDEFINED).c + ';\n'

			elif !isStatic and up isa InstanceInitBlock
				if @vscope
					if let fn = STACK.up(Func)
						@vscope.mergeScopeInto(fn.@scope)

				let ctor = up.option(:ctor)
				let opts = up.option(:opts)
				let val = value or UNDEFINED
				
				let paramIndex = option(:paramIndex)
				let restIndex = option(:restIndex)
				let access
				
				if paramIndex != undefined
					let name = option(:paramName)
					access = ctor.@params.at(paramIndex,yes,name)
					if value
						val = If.ternary(OP('!==',access,UNDEFINED),access,val)
					else
						val = access

				elif restIndex != undefined
					let rest = ctor.@params.at(restIndex,yes,'_fields')
					access = OP('.',rest,name)

					if value
						access.cache(reuse: yes, name: 'v')
						val = If.ternary(OP('&&',rest,OP('!==',access,UNDEFINED)),access,val)
					else
						val = If.ternary(rest,access,UNDEFINED)
				
				if self isa ClassAttribute and !value
					return

				out = OP('=',OP('.',THIS,name),val).c + ';\n'

		return out


	def getter
		@getter ||= if true
			# let op = OP('.',THIS,storageKey)
			let op = CALL(GET(storageMap,'get'),[THIS])
			let getter = op
			if value and false # and (!(value isa Str) and !(value isa Str) and !(value isa Bool) or @decorators)
				let inlined = (value isa Num) or (value isa Str) or (value isa Bool)
				let has = CALL(GET(storageMap,'has'),[THIS])
				if inlined
					op = METH([],[If.ternary(has,op,value)])
				else
					let setter = CALL(GET(storageMap,'set'),[THIS,value])
					op = IF(OP('!',has),setter)
					op = METH([],[op,BR,getter])
				op.traverse
				return op
			else
				return FN([],[op])

	def setterForValue value
		OP('=',OP('.',THIS,storageKey),value)

	def setter
		@setter ||= if true
			let op = CALL(GET(storageMap,'set'),[THIS,LIT('value')])
			# OP('=',OP('.',THIS,storageKey),LIT('value'))
			FN([LIT('value')],[op]).set(noreturn: true)

	def decorater
		@decorater ||= if true
			util.decorate(Arr.new(@decorators),target,name,LIT('null'))

export class ClassAttribute < ClassField
	def getter
		@getter ||= if true
			let op = CALL(GET(THIS,'getAttribute'),[name.toAttrString])
			FN([],[op])
	
	def setter
		@setter ||= if true
			let op = CALL(GET(THIS,'setAttribute'),[name.toAttrString,LIT('value')])
			FN([LIT('value')],[op]).set(noreturn: true)
	
	

export class ClassBody < Block

	def setup
		super
		@fields = []
		@staticFields = []

	def visit stack
		@scope.visit if @scope

		if stack and stack.@tag
			@tag = stack.@tag

		for node,i in @nodes
			if node isa Tag
				# add as render method
				# console.log 'add as render method'
				let meth = MethodDeclaration.new([],[node],Identifier.new('render'),null,{})
				@nodes[i] = node = meth

			node and node.traverse
		self

export class ExpressionList < Block

export class VarDeclList < Block
	
	def type
		option(:type) or 'var'

	def add part
		push(BR) if @nodes:length

		let node = VarDeclaration.new(part[0],part[1],type).set(decl: self, datatype: part[0].option(:datatype))
		unless @firstDeclaration
			@firstDeclaration = node
			node.set(keyword: keyword)
		push(node)
		return self

	def consume node
		if @nodes:length == 1
			return @nodes[0].consume(node)
		return self


# Could inherit from valueNode
export class Parens < ValueNode

	def initialize value, open, close
		setup
		@open = open
		@close = close
		@value = load(value)

	def load value
		@noparen = no
		value isa Block and value.count == 1 ? value.first : value

	def isString
		# checking if this is an interpolated string
		@open and String(@open) == '("' or value.isString

	def js o

		var par = up
		var v = @value
		var str = null

		@noparen = yes if v isa Func

		if par isa Block
			# is it worth it?
			@noparen = yes unless o.isExpression
			str = v isa Array ? AST.cary(v) : v.c(expression: o.isExpression)
		else
			str = v isa Array ? AST.cary(v) : v.c(expression: yes)

		# check if we really need parens here?
		return str

	def set obj
		console.log "Parens set {JSON.stringify(obj)}"
		super(obj)


	def shouldParenthesize
		# no need to parenthesize if this is a line in a block
		return no if @noparen #  or par isa ArgList
		return yes


	def prebreak br
		super(br)
		console.log "PREBREAK"
		@value.prebreak(br) if @value
		self


	def isExpressable
		@value.isExpressable

	def consume node
		@value.consume(node)


# Could inherit from valueNode
# an explicit expression-block (with parens) is somewhat different
# can be used to return after an expression
export class ExpressionBlock < ListNode


	def c o
		map(|item| item.c(o) ).join(",")

	def consume node
		value.consume(node)


# STATEMENTS

export class Return < Statement

	prop value

	def initialize v
		@traversed = no
		@value = v isa ArgList and v.count == 1 ? v.last : v
		return self

	def visit
		@value.traverse if @value && @value:traverse

	def startLoc
		let l = (keyword or @value)
		l ? l.startLoc : null

	def js o
		var v = @value
		let k = M('return',keyword)

		if v isa ArgList
			return "{k} [{v.c(expression: yes)}]"
		elif v
			return "{k} {v.c(expression: yes)}"
		else
			k

	def c
		return super if !value or value.isExpressable
		value.consume(self).c

	def consume node
		return self

export class ImplicitReturn < Return

export class GreedyReturn < ImplicitReturn

# cannot live inside an expression(!)
export class Throw < Statement

	def js o
		"throw {value.c}"

	def consume node
		# ROADMAP should possibly consume to the value of throw and then throw?
		return self


export class LoopFlowStatement < Statement

	prop literal
	prop expression

	def initialize lit, expr
		self.literal = lit
		self.expression = expr

	def visit
		expression.traverse if expression

	def consume node
		self

	def c
		return super unless expression
		# get up to the outer loop
		var _loop = STACK.up(Loop)

		# need to fix the grammar for this. Right now it
		# is like a fake call, but should only care about the first argument
		var expr = self.expression

		if _loop.catcher
			expr = expr.consume(_loop.catcher)
			var copy = self:constructor.new(literal)
			Block.new([expr,copy]).c
		elif expr
			var copy = self:constructor.new(literal)
			Block.new([expr,copy]).c
		else
			super
		# return "loopflow"


export class BreakStatement < LoopFlowStatement
	def js o do "break"

export class ContinueStatement < LoopFlowStatement
	def js o do "continue"

export class DebuggerStatement < Statement


# PARAMS

export class Param < Node

	prop name
	prop index
	prop defaults
	prop splat
	prop variable
	prop value

	def initialize value, defaults, typ
		# could have introduced bugs by moving back to identifier here
		if typeof value == 'string'
			value = Identifier.new(value)

		@traversed = no
		@name = value
		@value = value
		@defaults = defaults
		@typ = typ
		@variable = null

	def varname
		@variable ? @variable.c : name
		
	def type
		'param'
		
	def jsdoc
		let typ = option('datatype')
		if typ && name
			'@param {' + typ.c() + '} ' + name
		else
			''

	def js o
		if @defaults
			return "{@value.c} = {@defaults.c}"
		elif option(:splat)
			return "..." + @value.c
		else
			return @value.c

	def visit stack
		@defaults.traverse if @defaults
		@value.traverse(declaring: 'param') if @value

		# self.variable ||= scope__.register(name,self)

		if @value isa Identifier
			@value.@variable ||= scope__.register(@value.symbol,@value,type: type)
			stack.registerSemanticToken(@value)
			# change type here?
			# @name.@value.@type = "PARAMVAR" if @name.@value
			# @name.references(@variable)
			# @variable.addReference(@name)

		self

	def assignment
		OP('=',variable.accessor,defaults)

	def isExpressable
		!defaults || defaults.isExpressable

	def dump
		{loc: loc}

	def loc
		@name && @name.region

	def toJSON
		{
			type: typeName
			name: name
			defaults: defaults
		}
		
export class RestParam < Param

export class BlockParam < Param

	def c
		"blockparam"

	def loc
		# hacky.. cannot know for sure that this is right?
		var r = name.region
		[r[0] - 1,r[1]]


export class OptionalParam < Param

export class NamedParam < Param

export class RequiredParam < Param

export class ParamList < ListNode

	prop splat
	prop block

	def at index, force = no, name = null
		if force
			add(Param.new(count == index && name || "_{count}")) until count > index
			# need to visit at the same time, no?
		list[index]

	def metadata
		filter(|par| !(par isa Meta))

	def toJSON
		metadata
		
	def jsdoc
		let out = []
		for item in nodes when item isa Param
			if item.option(:datatype)
				out.push(item.jsdoc())
		let doc = out.join('\n')
		return (doc ? '/**\n' + doc + '\n*/\n' : '')

	def visit
		var blk = filter(|par| par isa BlockParam)

		if blk:length > 1
			blk[1].warn "a method can only have one &block parameter"

		elif blk[0] && blk[0] != last
			blk[0].warn "&block must be the last parameter of a method"
			# warn "&block must be the last parameter of a method", blk[0]

		# add more warnings later(!)
		# should probably throw error as well to stop compilation

		# need to register the required-pars as variables
		super

	def js o
		return EMPTY if count == 0

		if o.parent isa Block
			return head(o)

		# items = map(|arg| arg.name.c ).compact
		# return null unless items[0]

		if o.parent isa Code
			# return "params_here"
			# remove the splat, for sure.. need to handle the other items as well
			# this is messy with references to argvars etc etc. Fix
			var pars = nodes
			# pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
			# pars = filter(|arg| arg isa RequiredParam or arg isa OptionalParam) if @splat
			AST.compact(nodes.map(|param| param.c() )).join(",")
		else
			throw "not implemented paramlist js"
			"ta" + AST.compact(map(|arg| arg.c )).join(",")

	def head o
		var reg = []
		var opt = []
		var blk = null
		var splat = null
		var named = null
		var arys = []
		var signature = []
		var idx = 0

		nodes.forEach do |par,i|
			if par isa RawScript
				return

			par.index = idx
			if par isa OptionalParam
				signature.push('opt')
				opt.push(par)
			elif par isa BlockParam
				signature.push('blk')
				blk = par
			else
				signature.push('reg')
				reg.push(par)
			idx++

		if named
			var namedvar = named.variable

		# var opt = nodes.filter(|n| n isa OptionalParam)
		# var blk = nodes.filter(|n| n isa BlockParam)[0]
		# var splat = nodes.filter(|n| n isa SplatParam)[0]

		# simple situation where we simply switch
		# can probably optimize by not looking at arguments at all
		var ast = []
		var isFunc = do |js| "typeof {js} == 'function'"

		# This is broken when dealing with iframes anc XSS scripting
		# but for now it is the best test for actual arguments
		# can also do constructor.name == 'Object'
		var isObj = do |js| "{js}.constructor === Object"
		var isntObj = do |js| "{js}.constructor !== Object"
		# should handle some common cases in a cleaner (less verbose) manner
		# does this work with default params after optional ones? Is that even worth anything?
		# this only works in one direction now, unlike TupleAssign

		# we dont really check the length etc now -- so it is buggy for lots of arguments

		# if we have optional params in the regular order etc we can go the easy route
		# slightly hacky now. Should refactor all of these to use the signature?
		if !named && !splat && !blk && opt:length > 0 && signature.join(" ").match(/opt$/)
			for par,i in opt
				ast.push "if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}"


		elif named && !splat && !blk && opt:length == 0 # and no block?!
			# different shorthands
			# if named
			ast.push "if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \{\}"

		elif blk && opt:length == 1 && !splat && !named
			var op = opt[0]
			var opn = op.name.c
			var bn = blk.name.c
			ast.push "if({bn}==undefined && {isFunc(opn)}) {bn} = {opn},{opn} = {op.defaults.c}"
			ast.push "if({opn}==undefined) {opn} = {op.defaults.c}"

		elif blk && named && opt:length == 0 && !splat
			var bn = blk.name.c
			ast.push "if({bn}==undefined && {isFunc(namedvar.c)}) {bn} = {namedvar.c},{namedvar.c} = \{\}"
			ast.push "else if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \{\}"

		elif opt:length > 0 || splat # && blk  # && !splat

			var argvar = scope__.temporary(self, pool: 'arguments').predeclared.c
			var len = scope__.temporary(self, pool: 'counter').predeclared.c

			var last = "{argvar}[{len}-1]"
			var pop = "{argvar}[--{len}]"
			ast.push "var {argvar} = arguments, {len} = {argvar}.length"

			if blk
				var bn = blk.name.c
				if splat
					ast.push "var {bn} = {isFunc(last)} ? {pop} : null"
				elif reg:length > 0
					# ast.push "// several regs really?"
					ast.push "var {bn} = {len} > {reg:length} && {isFunc(last)} ? {pop} : null"
				else
					ast.push "var {bn} = {isFunc(last)} ? {pop} : null"

			# if we have named params - look for them before splat
			# should probably loop through pars in the same order they were added
			# should it be prioritized above optional objects??
			if named
				# should not include it when there is a splat?
				ast.push "var {namedvar.c} = {last}&&{isObj(last)} ? {pop} : \{\}"

			for par,i in opt
				ast.push "if({len} < {par.index + 1}) {par.name.c} = {par.defaults.c}"

			# add the splat
			if splat
				var sn = splat.name.c
				var si = splat.index

				if si == 0
					ast.push "var {sn} = new Array({len}>{si} ? {len} : 0)"
					ast.push "while({len}>{si}) {sn}[{len}-1] = {pop}"
				else
					ast.push "var {sn} = new Array({len}>{si} ? {len}-{si} : 0)"
					ast.push "while({len}>{si}) {sn}[--{len} - {si}] = {argvar}[{len}]"

			# if named
			# 	for k,i in named.nodes
			# 		# OP('.',namedvar) <- this is the right way, with invalid names etc
			# 		var op = OP('.',namedvar,k.key).c
			# 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"

			# if named

			# return ast.join(";\n") + ";"
			# return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"


		elif opt:length > 0
			for par,i in opt
				ast.push "if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}"

		# now set stuff if named params(!)

		if named
			for k,i in named.nodes
				# console.log "named var {k.c}"
				var op = OP('.',namedvar,k.c).c
				ast.push "var {k.c} = {op} !== undefined ? {op} : {k.defaults.c}"

		if arys:length
			for v,i in arys
				# create tuples
				v.head(o,ast,self)
				# ast.push v.c



		# if opt:length == 0
		return ast:length > 0 ? (ast.join(";\n") + ";") : EMPTY


# Legacy. Should move away from this?
export class ScopeVariables < ListNode

	# for later, moz-ast style
	prop kind
	prop split

	# we want to register these variables in
	def add name, init, pos = -1
		var vardec = VariableDeclarator.new(name,init)
		vardec.variable = name if name isa Variable
		pos == 0 ? unshift(vardec) : push(vardec)
		vardec

	def load list

		list.map do |par| VariableDeclarator.new(par.name,par.defaults,par.splat)

	def isExpressable
		nodes.every(|item| item.isExpressable)

	def js o
		return EMPTY if count == 0

		# When is this needed?
		if count == 1 && !isExpressable
			first.variable.autodeclare
			var node = first.assignment
			return node.c

		
		var keyword = 'var'
		var groups = {}

		nodes.forEach do |item|
			let variable = item.@variable or item

			let typ = variable isa Variable and variable.type
			if typ
				groups[typ] ||= []
				groups[typ].push(item)
			# elif item.@variable
			#	console.log 'variable without type'
			# else
			#	console.log "no variable type?? {item:constructor} {item.type}"

		if groups['let'] and (groups['var'] or groups['const'])
			groups['let'].forEach do |item|
				(item.@variable or item).@virtual = yes

		elif groups['let']
			keyword = 'let'

		# FIX PERFORMANCE
		# This is used in let scope as well - inflexible
		if split and true
			let out2 = []
			for own k,v of groups
				out2.push "{k} {AST.cary(v).join(', ')};"
			return out2.join("\n")

		var out = AST.compact(AST.cary(nodes)).join(", ")
		out ? "{keyword} {out}" : ""

export class VariableDeclarator < Param
	
	prop type
	# can possibly create the variable immediately but wait with scope-declaring
	# What if this is merely the declaration of a system/temporary variable?
	def visit
		# even if we should traverse the defaults as if this variable does not exist
		# we need to preregister it and then activate it later
		self.variable ||= scope__.register(name,null, type: @type or 'var')
		defaults.traverse if defaults
		# WARN what if it is already declared?
		self.variable.declarator = self
		self.variable.addReference(name)
		self

	# needs to be linked up to the actual scoped variables, no?
	def js o
		return null if variable.@proxy

		var defs = defaults
		# FIXME need to deal with var-defines within other statements etc
		# FIXME need better syntax for this
		if defs != null && defs != undefined
			# console.log "defaults is {defaults}"
			defs = defs.c(expression: yes) if defs isa Node

			"{variable.c} = {defs}"
		else
			"{variable.c}"

	def accessor
		self


export class VarDeclaration < Node

	prop kind
	prop left
	prop right

	def op
		'='
	
	def type
		@kind

	def initialize left, right, kind
		@left = left
		@right = right
		@kind = kind
		
	def visit stack
		unless @left isa Identifier and @right isa Func
			@right.traverse if @right

		@left.traverse(declaring: type) if @left
		
		# replace directly
		# should the left side be wrapped in a VarDeclLeft node?
		if @left isa Identifier
			# TODO add an identifier.declare method for this
			@left.@variable ||= scope__.register(@left.symbol,@left,type: type)
			stack.registerSemanticToken(@left)
			
		@right.traverse if @right

		# elif @left isa Obj
		# 	# need to traverse the object to register variables
		# 	# if it is a let we might also need to rename them though
			
		self

	def isExpressable
		no

	def consume node
		if node isa TagLike
			return self

		if node isa PushAssign or node isa Return
			let ast = self
			if right and !right.isExpressable
				let temp = scope__.temporary(self)
				let ast = right.consume(OP('=',temp,NULL))
				right = temp
				return Block.new([ast,BR,self.consume(node)])

			return Block.new([ast,BR,@left.consume(node)])

		if node isa Return
			return Block.new([self,BR,@left.consume(node)])
	
		super(node)
		
	def c o
		if right and !right.isExpressable
			let temp = scope__.temporary(self)
			let ast = right.consume(OP('=',temp,NULL))
			right = temp
			return Block.new([ast,BR,self]).c(o)
		# testing this
		return super(o)
		
	def js
		let out = "{M(kind,keyword)} {left.c()}"
		if right
			out += " = {right.c(expression: true)}"
			
		if option(:export)
			if STACK.cjs
				out = "{out};\nexports.{left.c()} = {left.c()}"
			else
				out = M('export',option(:export)) + " {out}"
			
		if let typ = datatype
			out = '/** @type {' + typ.c() + '} */\n' + out

		return out

# TODO clean up and refactor all the different representations of vars
export class VarName < ValueNode

	prop variable
	prop splat

	def initialize a,b
		super
		@splat = b

	def visit
		# should we not lookup instead?
		# FIXME p "register value {value.c}"
		self.variable ||= scope__.register(value.c,null)
		self.variable.declarator = self
		self.variable.addReference(value)
		self

	def js o
		variable.c

	def c
		variable.c

# CODE

export class Code < Node

	prop head
	prop body
	prop scope
	prop params

	def scopetype
		Scope

	def visit
		@scope.visit if @scope
		# @scope.parent = STACK.scope(1) if @scope
		self


# Rename to Program?
export class Root < Code

	def initialize body, opts
		@traversed = no
		@body = AST.blk(body)
		@scope = RootScope.new(self,null)
		@options = {}

	def loc
		@body.loc

	def visit
		ROOT = STACK.ROOT = @scope
		try
			scope.visit
			body.traverse
			if body.first isa Terminator
				body.first.@first = yes
		catch e
			let err = ImbaTraverseError.wrap(e)
			err.@sourcePath = OPTS:sourcePath
			err.@loc = STACK.currentRegion()
			throw err
			

	def compile o
		STACK.reset # -- nested compilation does not work now
		@scope.options = OPTS = STACK.@options = @options = o or {}
		STACK.root = @scope
		traverse
		STACK.root = @scope
		
		if o:onTraversed isa Function
			o:onTraversed(self,STACK)
		
		var out = c(o)

		if STACK.tsc
			out = "import 'imba/index';\n{out}"

		var result = {
			js: out,
			ast: self,
			sourceId: sourceId,
			source: o.@source,
			tokens: o.@tokens,
			warnings: scope.warnings,
			options: o,
			toString: (do this:js)
			styles: scope.styles,
			assets: scope.assets
		}
		
		if !STACK.tsc
			var stylebody = ""
			for style in result:styles
				if style:type == 'css'
					stylebody += style:processed + '\n\n'

			result:css = stylebody

			if stylebody and o:css != 'separate'
				# and o:bundler != 'webpack'
				let css = {js: stylebody}
				# maybe do something different when server etc?
				# css:js = "/* styles from {o:sourcePath} */\n" + css:js
				
				result:js = "{result:js}\nimba.css.register({JSON.stringify(result:css)},'{result:sourceId}');"
				result:js += '\n/*\n' + result:css + '\n*/\n'
				result:styles:inlined = yes

		# always create the sourcemap?
		if o:sourceMap # should handle sourcemap no matter what?
			let map = SourceMap.new(result,o:sourceMap,o).generate
			result:sourcemap = map.result
		# else
		# remove sourcemap locations
		result:js = result:js.replace(/\/\*\%([\w\|]*)\$\*\//g,'')

		return result

	def js o
		var out
		unless @options:wrap
			out = scope.c
		else
			body.consume(ImplicitReturn.new)
			out = scope.c(indent: yes)
			out = out.replace(/^\n?/,'\n')
			out = out.replace(/\n?$/,'\n\n')
			out = '(function(){' + out + '})();'

		# find and replace shebangs
		var shebangs = []
		out = out.replace(/^[ \t]*\/\/(\!.+)$/mg) do |m,shebang|
			shebang = shebang.replace(/\bimba\b/g,'node')
			shebangs.push("#{shebang}\n")
			return ""

		out = shebangs.join('') + out

		return out


	def analyze o = {}
		# loglevel: 0, entities: no, scopes: yes
		STACK.loglevel = o:loglevel or 0
		STACK.@analyzing = true
		ROOT = STACK.ROOT = @scope
		OPTS = STACK.@options = {
			platform: o:platform
			loglevel: o:loglevel or 0
			analysis: {
				entities: (o:entities or no),
				scopes: (o:scopes ?= yes)
			}
		}

		traverse
		STACK.@analyzing = false

		return scope.dump

	def inspect
		true

export class ClassDeclaration < Code

	prop name
	prop superclass
	prop initor

	def consume node
		if node isa Return
			option('return',node)
			return self
		super

	def namepath
		@namepath ||= "{name ? name.c : '--'}"

	def metadata
		{
			type: 'class'
			namepath: namepath
			inherits: superclass?.namepath
			path: name and name.c.toString
			desc: @desc
			loc: loc
			symbols: @scope.entities
		}
		
	def loc
		if let d = option(:keyword)
			[d.@loc,body.loc[1]]
		else
			super

	def startLoc
		@startLoc ?= MSTART(option(:export),option(:keyword))

	def endLoc
		@endLoc ?= MEND(body)

	def toJSON
		metadata

	def isStruct
		keyword and String(keyword) == 'struct'
	
	def isExtension
		option(:extension)

	def initialize name, superclass, body
		# what about the namespace?
		@traversed = no
		if name isa VarOrAccess
			name = name.@value

		@name = name # or LIT('')
		@superclass = superclass
		@scope = isTag ? TagScope.new(self) : ClassScope.new(self)
		@body = AST.blk(body) or ClassBody.new([])
		@entities = {} # items should register the entities as they come
		self

	def isTag
		no

	def staticInit
		# @superclass ? 'super.inherited instanceof Function && super.inherited(this)' : 'this'
		@staticInit ||= addMethod('init$',[],'this').set(static: yes)

	def instanceInit
		@instanceInit ||= addMethod('init$',[],isTag ? 'super.init$()' : '').set(noreturn: yes)

	def visit
		# replace with some advanced lookup?
		@body.@delimiter = ''
		
		STACK.pop(self)
		
		if @superclass
			@superclass.traverse()
			# also visit and possibly declare the class name?
			
		if option(:extension) and @name
			@name.traverse()
			if @name isa Identifier
				@name.resolveVariable()

		elif @name
			# TODO should actually declare in outer scope
			@name.traverse(declaring: self)
		
		STACK.push(self)

		ROOT.entities.add(namepath,self)
		scope.visit

		# if @superclass and !option(:extension) and !STACK.tsc
		#	staticInit
		
		var fields = []
		var signature = []
		var params = []
		var declaredFields = {}
		var restIndex = undefined
		
		
		for node in body when node isa ClassField
			if !node.isStatic
				let name = String(node.name)
				declaredFields[name] = node
		
		if option(:params)
			# find the rest param
			let add = []
			for param,index in option(:params)
				
				if param isa RestParam
					restIndex = index
					continue
					
				let name = String(param.name)
				let field = declaredFields[name]
				let dtyp = param.option(:datatype)

				if !field
					field = fields[name] = ClassField.new(param.name).set(
						datatype: dtyp
						value: param.defaults
					)
					# field.set(param: param)
					add.push(field)
					params.push(param)
				else
					if dtyp and !field.datatype
						field.set(datatype: dtyp)
					if param.defaults and !field.value
						field.set(value: param.defaults)
				
				if field
					field.set(paramIndex: index, paramName: name)

			for item in add.reverse
				body.unshift(item)

		body.traverse

		if STACK.tsc
			return self

		var inits = InstanceInitBlock.new()
		var staticInits = ClassInitBlock.new()
		var ctor = body.option(:ctor)

		for node in body when node isa ClassField
			if node.hasStaticInits
				staticInits.add(node)
			if node.hasConstructorInits
				inits.add(node)
				
			if !node.isStatic and restIndex != null
				node.set(restIndex: restIndex)

		for node,i in body
			if node.@decorators
				let target = node.option(:static) ? THIS : PROTO
				let desc = LIT('null')
				let op = util.decorate(Arr.new(node.@decorators),target,node.name,desc)
				staticInits.add([op,BR])
				# LIT(node.name.c)

		if !inits.isEmpty
			if isTag
				ctor = instanceInit
				inits.set(ctor: ctor)
				ctor.inject(inits)

			elif ctor
				let after = ctor.option(:injectInitAfter)
				# inject before/after super or something
				inits.set(ctor: ctor)
				ctor.inject(inits,after ? {after: after} : 0)
			else
				ctor = addMethod('constructor',[],superclass ? 'super(...arguments)' : '')
				inits.set(ctor: ctor)
				ctor.inject(BR)
				ctor.inject(inits)

		if !staticInits.isEmpty
			staticInit.inject(staticInits,0)
		self

	def addMethod name, params, mbody, options
		mbody = [LIT(mbody)] if mbody isa String
		let func = MethodDeclaration.new(params,mbody or [],Identifier.new(name),null,options or {})
		self.body.unshift(func,yes)
		func.traverse
		return func

	# def addGetter name, body

	# def addSetter name, body

	def js o
		scope.virtualize # is this always needed?
		scope.context.value = name
		scope.context.reference = name

		# should probably also warn about stuff etc
		if option(:extension)
			# fields are not allowed in class extensions?
			@body.@delimiter = ','
			@body.set(braces: yes)
			# TODO should rather declare a variable for the class name, and refer to that?
			return util.extend(LIT(name.c),body).c
			# return body.c

		# if there are superclasses - add to the body
		# addMethod('super$set','return super[k] = v')


		var o = @options or {}
		var cname = name isa Access ? name.right : name
		# var namespaced = name != cname
		var initor = null
		var sup = superclass

		if typeof cname != 'string' and cname
			cname = cname.c(mark: yes)

		@cname = cname
		
		let jsbody = body.c()
		let jshead = M('class',keyword) # "{C(keyword,mark: yes)}"
		jshead += " {M cname, name}" if name
		jshead += " extends {M(sup)}" if sup

		if name isa Access
			# if staticInit we need a reference to it after
			jshead = "{name.c} = {jshead}"
		
		if option(:export) and !STACK.cjs
			if option(:default)
				jshead = "{M 'export',option(:export)} {M 'default',option(:default)} {jshead}"
			else
				jshead = "{M 'export',option(:export)} {jshead}"

		let js = "{jshead} \{{jsbody}\}"
		
		if option(:export) and STACK.cjs
			let exportName = option(:default) ? 'default' : cname
			js = "{js};\n{M('exports',o:export)}.{exportName} = {cname}"
			
		if option(:global)
			js = "{js}; {scope__.root.globalRef}.{@cname} = {@cname}"

		if @staticInit
			# this means we need to cache it 
			js = "{js}; {cname}.init$();"
			
		# if STACK.tsc
		# 	let comment = "/*Â¡{cname}*/"
		# 	let add = helpers.clearLocationMarkers("{cname}.{comment}prototype.constructor;")
		# 	js = "{js}; {add}"

		return js
		
export class StructInitBody < Block

export class StructDeclaration < ClassDeclaration

	def visit
		# replace with some advanced lookup?
		@body.@delimiter = ''
		ROOT.entities.add(namepath,self)
		scope.visit
		
		var fields = []
		var signature = []
		var params = []
		
		if option(:params)
			for param in option(:params).reverse
				let name = String(param.name)
				
				let field = ClassField.new(param.name).set(
					datatype: param.option(:datatype)
					value: param.defaults
				)
				field.set(param: param)

				body.unshift(field)
				params.unshift(param)
				
		params.push(LIT('$$={}'))
		
		let prevSignificant
		for node,i in body
			if node isa Terminator
				body.replace(node,BR0) if prevSignificant isa ClassField 
			else
				prevSignificant = node
				
			if node isa ClassField
				let name = String(node.name)
				let field = node
				if fields[name]
					unless fields[name].datatype
						fields[name].set(datatype: node.datatype)
				else
					node.set(struct: self, raw: yes)
					fields.push(fields[name] = node)

				body.replace(node,BR0)

		body.traverse

		if STACK.tsc
			return self

		var ctor = body.option(:ctor)
	
		var inits = StructInitBody.new([])
		var setters = []

		for field in fields
			# check if null?
			# let param = LIT('$$')
			let access = OP('.',THIS,field.name)
			let setter = OP('.',LIT('$$'),field.name)
			
			if field.option(:param)
				setter = field.option(:param).name
			
			if field.value
				setter = OP('||',setter,field.value)
				# let op = OP('=',access,setter)
			
			let assign = OP('=',access,setter).set(datatype: field.datatype)
			# setters.push(OP('=',access,setter))
			inits.add([assign,BR])
			# ctorBody.push(OP('=',THIS,name).c + ';\n')
		
		# replace the whole body
		# @body = ClassBody.new([])
		# @body.@delimiter = ''
		ctor = addMethod('constructor',params,inits)
		# add existing methods for cloning etc
		return self

export class TagDeclaration < ClassDeclaration

	def isTag
		yes

	def namepath
		"<{name}>"

	def metadata
		Object.assign(super,{
			type: 'tag'
		})
	
	def cssns
		"{sourceId}{oid}"
		
	def cssref scope
		if isNeverExtended and !superclass
			return option(:hasScopedStyles) ? cssns : null

		let s = scope.closure
		return s.memovar('_ns_',OP('||',OP('.',s.context,'_ns_'),STR('')))
		
	def isNeverExtended
		if name and name.isClass
			return !option(:export) and !option(:extended)
		else
			no

	def visit
		scope__.imbaDependency('index')

		super

		let sup = superclass
	
		@config = {}

		if sup and !STACK.tsc
			if (sup.isNative or sup.isNativeSVG)
				let op = sup.nativeCreateNode
				op = util.extendTag(op,THIS)
				addMethod('create$',[],[op]).set(static: yes)
				set(extends: Obj.wrap(extends: sup.name))
				@config:extends = sup.name
			elif sup.isClass
				sup.resolveVariable(scope__.parent)
				let up = sup.@variable && sup.@variable.value
				up.set(extended: self) if up
		
		if @elementReferences
			for own ref,child of @elementReferences
				if STACK.tsc
					let val = child.option(:reference)
					let typ = child.type
					let op = "{M(AST.sym(val),val)}"
					if typ and typ:toClassName
						op += " = new {typ.toClassName}"
					
					self.body.unshift(LIT(op + ';'),yes)
		return
		
	def addElementReference name, child
		let refs = @elementReferences ||= {}
		refs[name] = child

	def js s
		scope.virtualize # is this always needed?
		scope.context.value = name
		scope.context.reference = name
		
		
		
		let className = name.toClassName
		let sup = superclass
		
		if sup and sup.@variable
			sup = sup.@variable
		elif sup
			sup = CALL(LIT('imba.tags.get'),[sup,STR(sup.toClassName)])
		else
			sup = CALL(LIT('imba.tags.get'),[STR('component'),STR('ImbaElement')])

		if STACK.tsc
			sup = superclass ? superclass.toClassName : LIT('HTMLElement')

			if option(:extension)
				className = "Extended${className}"

			# if false
			# let comment = "/*Â¡{name.c.slice(1,-1)}*/"
			# let add = helpers.clearLocationMarkers("this.{comment}prototype.constructor;")
			# let fn = 'static meta$(){ ' + add + ' }\n'
			# body.unshift(LIT(fn))

		elif option(:extension)
			@body.@delimiter = ','
			@body.set(braces: yes)
			let cls = CALL(LIT('imba.tags.get'),[name,STR(name.toClassName)])
			let tagname = TagTypeIdentifier.new(name)
			return util.extend(cls,body).c

		
		let closure = scope__.parent
		let jsbody = body.c()
		let jshead = "{M 'class', keyword} {M className, name} extends {M sup, superclass}"
		
		if option(:export) and !STACK.cjs
			if option(:default)
				jshead = "{M 'export',option(:export)} {M 'default',option(:default)} {jshead}"
			else
				jshead = "{M 'export',option(:export)} {jshead}"

		let js = "{jshead} \{{jsbody}\}"
		
		if option(:export) and STACK.cjs
			let exportName = option(:default) ? 'default' : className
			js = "{js};\n{M('exports',o:export)}.{exportName} = {className}"

		@config:ns = cssns if option(:hasScopedStyles)

		if !STACK.tsc
			if @staticInit
				js += "; {className}.init$()"
			# let ext = (option(:extends) or LIT('{}')).c
			let ext = Obj.wrap(@config).c
			js += "; imba.tags.define({name.c},{className},{ext})"
		else
			unless option(:extension)
				js += "; globalThis.{M className, name} = {className};"
			# let comment = "/*Â¡{name.c.slice(1,-1)}*/"
			# js +=  helpers.clearLocationMarkers("{className}.{comment}prototype.constructor")
		return js

export class Func < Code

	prop name
	prop params
	prop target
	prop options
	prop type
	prop context

	def scopetype do FunctionScope

	def initialize params, body, name, target, o
		@options = o
		var typ = scopetype
		@traversed = no
		@body = AST.blk(body)
		@scope ||= (o and o:scope) || typ.new(self)
		@scope.params = @params = ParamList.new(params)
		@name = name || ''
		@target = target
		@type = :function
		@variable = null
		self

	def inject line, o
		@body.add([line,BR],o)

	def nonlocals
		@scope.@nonlocals

	def visit stack, o
		scope.visit
		@context = scope.parent
		@params.traverse(declaring: 'arg')
		@body.traverse # so soon?

	def funcKeyword
		let str = "function"
		str = "async {str}" if option(:async)
		return str

	def js s,o
		body.consume(ImplicitReturn.new) unless option(:noreturn)
		var ind = body.@indentation
		# var s = ind and ind.@open
		body.@indentation = null if ind and ind.isGenerated
		var code = scope.c(indent: (!ind or !ind.isGenerated), braces: yes)

		# args = params.map do |par| par.name
		# head = params.map do |par| par.c
		# code = [head,body.c(expression: no)].AST.flatten.compact.join("\n").wrap
		# FIXME creating the function-name this way is prone to create naming-collisions
		# will need to wrap the value in a FunctionName which takes care of looking up scope
		# and possibly dealing with it
		var name = typeof @name == 'string' ? @name : @name.c
		name = name ? ' ' + name.replace(/\./g,'_') : ''
		var keyword = o and o:keyword != undefined ? o:keyword : funcKeyword
		var out = "{M(keyword,option('def') or option('keyword'))}{name}({params.c}) " + code
		# out = "async {out}" if option(:async)
		out = "({out})()" if option(:eval)
		return out

	def shouldParenthesize par = up
		par isa Call && par.callee == self
		# if up as a call? Only if we are

export class IsolatedFunc < Func
	prop leaks

	def scopetype do IsolatedFunctionScope
	
	def isStatic
		yes
		
	def isPrimitive
		yes

	def visit stack
		super
		
		return if stack.tsc

		if let leaks = @scope.@leaks
			@leaks = []
			leaks.forEach do |shadow,source|
				shadow.@proxy = @params.at(@params.count,yes)
				@leaks.push(source)
		self

export class Lambda < Func
	def scopetype
		var k = option(:keyword)
		(k and k.@value == 'Æ’') ? (MethodScope) : (LambdaScope)

export class ClosedFunc < Func
	def scopetype
		MethodScope

export class TagFragmentFunc < Func

	def scopetype
		# caching still needs to be local no matter what?
		option(:closed) ? (MethodScope) : (LambdaScope)

export class MethodDeclaration < Func

	prop variable
	prop decorators

	def scopetype do MethodScope

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super

	def identifier
		@name

	def metadata
		{
			type: "method"
			name: "" + name
			namepath: namepath
			params: @params.metadata
			desc: @desc
			scopenr: scope.@nr
			loc: loc
		}

	def loc
		if let d = option(:def)
			let end = body.option(:end) or body.loc[1]
			[d.@loc,end]
		else
			[0,0]

	def isGetter
		@type == 'get'

	def isSetter
		@type == 'set'

	def isConstructor
		String(name) == 'constructor'

	def toJSON
		metadata

	def namepath
		return @namepath if @namepath

		var name = String(name.c)
		var sep = (option('static') ? '.' : '#')
		if target
			let ctx = target
			# console.log "target?? {@target.@parent} {@context.node}"
			if ctx.namepath == "ValueNode"
				ctx = @context.node

			@namepath = ctx.namepath + sep + name
		else
			@namepath = '&' + name

	def visit
		@type = option(:type) or (option(:def)?.@value or 'def')
		@decorators = up?.collectDecorators

		var o = @options
		scope.visit
			
		if option(:inObject)
			@params.traverse
			@body.traverse
			return self
		
		var closure = @context = scope.parent.closure
		
		if closure isa RootScope and !target
			scope.@context = closure.context
		
		elif closure isa MethodScope and !target
			scope.@selfless = yes

		@params.traverse
			
		if target isa Identifier
			if let variable = scope.lookup(target.toString)
				target = variable
			# should be changed to VarOrAccess?!

		if String(name) == 'initialize' and (closure isa ClassScope) and !(closure isa TagScope)
			self.type = :constructor

		if String(name) == 'constructor' or isConstructor
			up.set(ctor: self)
			set(noreturn: yes)
		
		# instance-method / member
		if closure isa ClassScope and !target
			@target = closure.prototype
			set(
				prototype: @target,
				inClassBody: yes,
				inExtension: closure.node.option('extension')
			)
			closure.annotate(self)

		if target isa Self
			@target = closure.context
			closure.annotate(self)
			set(static: yes)
			
		elif o:variable
			
			@variable = scope.parent.register(name, self, type: String(o:variable))
			warn "{String(o:variable)} def cannot have a target" if target

		elif !target
			
			@variable = scope.parent.register(name,self,type: 'const')
			yes
		
		if o:export and !(closure isa RootScope)
			warn("cannot export non-root method", loc: o:export.loc)

		ROOT.entities.add(namepath,self)
		
		@body.traverse

		if isConstructor and option(:supr)
			let ref = scope__.context.@reference
			let supr = option(:supr)
			let node = supr:node
			let block = supr:block

			if ref
				ref.declarator.@defaults = null
				let op = OP('=',ref,This.new)
				block.replace node, [node,op]

		self

	def supername
		type == :constructor ? type : name


	# FIXME export global etc are NOT valid for methods inside any other scope than
	# the outermost scope (root)

	def js o
		var o = @options
		# FIXME Do this in the grammar - remnants of old implementation
		unless type == :constructor or option(:noreturn) or isSetter()
			if option(:chainable)
				body.add(ImplicitReturn.new(scope.context))
			elif option(:greedy)
				# haaack
				body.consume(GreedyReturn.new)
			else
				body.consume(ImplicitReturn.new)

		var code = scope.c(indent: yes, braces: yes)
		var name = typeof @name == 'string' ? @name : @name.c()

		var out = ""
		var fname = AST.sym(self.name)

		if option(:inClassBody) or option(:inObject)
			# what if this is async?
			let prefix = self.isGetter() ? 'get ' : (self.isSetter() ? 'set ' : '')
			prefix = "async {prefix}" if option(:async)
			prefix = "{M('static',option(:static))} {prefix}" if option(:static)
			out = "{prefix}{M name, @name}({params.c}){code}"
			
			out = @params.jsdoc() + out

			return out

		var func = "({params.c})" + code
		var ctx = context

		if target
			if fname[0] == '['
				fname = fname.slice(1,-1)
			else
				fname = "'{fname}'"
			if isGetter
				out = "Object.defineProperty({target.c},'{fname}',\{get: {funcKeyword}{func}, configurable: true\})"
			elif isSetter
				out = "Object.defineProperty({target.c},'{fname}',\{set: {funcKeyword}{func}, configurable: true\})"
			else
				let k = OP('.',target,@name)
				out = "{k.c} = {funcKeyword} {func}"

			if o:export
				out = "exports.{o:default ? 'default' : fname} = {out}"
		else
			out = "{M funcKeyword, keyword} {M fname, @name}{func}"
			if o:export
				if STACK.cjs
					let exportName = o:default ? 'default' : fname
					out = "{out};\n{M('exports',o:export)}.{exportName} = {fname}"
				else
					out = "{M('export',o:export)} {o:default ? M('default ',o:default) : ''}{out}"

		if o:global
			out = "{out}; {scope__.root.globalRef}.{fname} = {fname};"
		
		if option(:return)
			out = "return {out}"

		return out

# Literals should probably not inherit from the same parent
# as arrays, tuples, objects would be better off inheriting
# from listnode.

export class Literal < ValueNode

	def initialize v
		@traversed = no
		@expression = yes
		@cache = null
		@raw = null
		@value = load(v)
		
	def load value
		value
		

	def toString
		"" + value

	def hasSideEffects
		false

	def shouldParenthesizeInTernary
		no

	def startLoc
		@startLoc or (@value:startLoc && @value.startLoc)

	def endLoc
		@endLoc or (@value:endLoc && @value.endLoc)

export class RawScript < Literal

	def c
		@value

export class Bool < Literal

	# Should keep the real value (yes/no/true/false)?
	def initialize v
		@value = v
		@raw = String(v) == "true" ? true : false

	def cache
		self

	def isPrimitive
		yes

	def truthy
		String(value) == "true"
		# yes

	def js o
		String(@value)

	def c
		STACK.@counter += 1
		# undefined should not be a bool
		String(@value)
		# @raw ? "true" : "false"

	def toJSON
		{type: 'Bool', value: @value}

	def loc
		@value:region ? @value.region : [0,0]

export class Undefined < Literal

	def isPrimitive
		yes

	def isTruthy
		no
		
	def cache
		self

	def c
		M("undefined",@value)

export class Nil < Literal

	def isPrimitive
		yes

	def isTruthy
		no
		
	def cache
		self

	def c
		M("null",@value)

export class True < Bool

	def raw
		true

	def isTruthy
		yes

	def c
		M("true",@value)

export class False < Bool

	def raw
		false

	def isTruthy
		no

	def c
		M("false",@value)

export class Num < Literal

	# value is token - should not be
	def initialize v
		@traversed = no
		@value = v

	def toString
		String(@value).replace(/\_/g,'')

	def toNumber
		@number ?= parseFloat(toString)

	def isPrimitive deep
		yes

	def isTruthy
		toNumber != 0
		
	def negate
		@value = -toNumber
		self

	def shouldParenthesize par = up
		par isa Access and par.left == self

	def js o
		return toString

	def c o
		return super(o) if @cache
		var out = M(toString,@value)
		var par = STACK.current
		var paren = par isa Access and par.left == self
		# only if this is the right part of the access
		paren ? "({out})" : out

	def cache o
		return self unless o and (o:cache or o:pool)
		super(o)

	def raw
		# really?
		JSON.parse(toString)

	def toJSON
		{type: typeName, value: raw}

export class NumWithUnit < Literal
	def initialize v, unit
		@traversed = no
		@value = v
		@unit = unit
	
	def negate
		set(negate: yes)
		return self
	
	def c o
		let raw = "{String(@value)}{String(@unit)}"
		raw = "-{raw}" if option(:negate)
		o and o:css ? raw : "'{raw}'"
	
export class ExpressionWithUnit < ValueNode
	
	def initialize value, unit
		@value = value
		@unit = unit
	
	def js o
		# util.unit(@value,STR(@unit)).c
		# let out = typeof @value == 'string' ? @value : @value.c
		"({value.c}+{STR(@unit).c})"
	
# should be quoted no?
# what about strings in object-literals?
# we want to be able to see if the values are allowed
export class Str < Literal

	def initialize v
		@traversed = no
		@expression = yes
		@cache = null
		@value = v
		# should grab the actual value immediately?

	def isString
		yes

	def isPrimitive deep
		yes

	def raw
		# JSON.parse requires double-quoted strings,
		# while eval also allows single quotes.
		# NEXT eval is not accessible like this
		# WARNING TODO be careful! - should clean up

		@raw ||= String(value).slice(1,-1) # incredibly stupid solution

	def isValidIdentifier
		# there are also some values we cannot use
		raw.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false

	def js o
		String(@value)

	def c o
		@cache ? super(o) : (M js, @value)

export class TemplateString < ListNode

	def js
		let parts = @nodes.map do |node|
			node isa String ? node : node.c()

		let out = '`' + parts.join('') + '`'
		return out

export class Interpolation < ValueNode

# Currently not used - it would be better to use this
# for real interpolated strings though, than to break
# them up into their parts before parsing
export class InterpolatedString < Node

	def initialize nodes, o = {}
		@nodes = nodes
		@options = o
		self

	def add part
		@nodes.push(part) if part
		self

	def visit
		for node in @nodes
			node.traverse
		self
		
	def isString
		yes

	def escapeString str
		str = str.replace(/\n/g, '\\\n')
		
	def toArray
		let items = @nodes.map do |part,i|
			if part isa Token and part.@type == 'NEOSTRING'
				Str.new('"' + part.@value + '"')
			else
				part
				
		return items

	def js o
		var kind = String(option("open") or '"')
		if kind:length == 3
			kind = kind[0]
		# creating the string
		var parts = []
		var str = @noparen ? '' : '('

		@nodes.map do |part,i|
			if part isa Token and part.@type == 'NEOSTRING'
				# esca
				parts.push(kind + escapeString(part.@value) + kind)
			elif part
				if i == 0
					# force first part to be string
					parts.push('""')
				part.@parens = yes
				parts.push(part.c(expression: yes))

		str += parts.join(" + ")
		str += ')' unless @noparen
		return str

# Because we've dropped the Str-wrapper it is kinda difficult
export class Symbol < Literal

	def isValidIdentifier
		raw.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false

	def isPrimitive deep
		yes

	def raw
		@raw ||= AST.sym(value.toString.replace(/^\:/,''))

	def js o
		"'{AST.sym(raw)}'"

export class RegExp < Literal

	def isPrimitive
		yes

	def js
		var v = super
		
		# special casing heregex
		if var m = constants.HEREGEX.exec(v)
			# console.log 'matxhed heregex',m
			var re = m[1].replace(constants.HEREGEX_OMIT, '').replace(/\//g, '\\/')
			return '/' + (re or '(?:)') + '/' + m[2]
		
		v == '//' ? '/(?:)/' : v

# Should inherit from ListNode - would simplify
export class Arr < Literal

	def load value
		value isa Array ? ArgList.new(value) : value

	def push item
		value.push(item)
		self

	def count
		value:length

	def nodes
		var val = value
		val isa Array ? val : val.nodes

	def splat
		value.some(|v| v isa Splat)

	def visit
		@value.traverse if @value and @value:traverse
		self

	def isPrimitive deep
		!value.some(|v| !v.isPrimitive(yes) )

	def js o
		var val = @value
		return "[]" unless val
		var nodes = val isa Array ? val : val.nodes
		var out = val isa Array ? AST.cary(val) : val.c
		"[{out}]"

	def hasSideEffects
		value.some(|v| v.hasSideEffects )

	def toString
		"Arr"

	def indented a,b
		@value.indented(a,b)
		self

	def self.wrap val
		Arr.new(val)

# should not be cklassified as a literal?
export class Obj < Literal

	def load value
		value isa Array ? AssignList.new(value) : value

	def visit
		@value.traverse if @value
		# for v in value
		# 	v.traverse
		self

	def isPrimitive deep
		!value.some(|v| !v.isPrimitive(yes) )

	def js o
		var dyn = value.filter(|v| v isa ObjAttr and (v.key isa Op or v.key isa InterpolatedString)  )

		if dyn:length > 0
			var idx = value.indexOf(dyn[0])
			# create a temp variable

			var tmp = scope__.temporary(self)
			# set the temporary object to the same
			var first = value.slice(0,idx)
			var obj = Obj.new(first)
			var ast = [OP('=',tmp,obj)]

			value.slice(idx).forEach do |atr|
				ast.push(OP('=',OP('.',tmp,atr.key),atr.value))
			ast.push(tmp) # access the tmp at in the last part
			return Parens.new(ast).c

		# for objects with expression-keys we need to think differently
		'{' + value.c + '}'

	def add k, v
		k = Identifier.new(k) if k isa String or k isa Token
		var kv = ObjAttr.new(k,v)
		value.push(kv)
		return kv

	def remove key
		for k in value
			value.remove(k) if k.key.symbol == key
		self

	def keys
		Object.keys(hash)

	def hash
		var hash = {}
		for k in value
			hash[k.key.symbol] = k.value if k isa ObjAttr
		return hash
		# return k if k.key.symbol == key

	# add method for finding properties etc?
	def key key
		for k in value
			return k if k isa ObjAttr and k.key.symbol == key
		null

	def indented a,b
		@value.indented(a,b)
		self

	def hasSideEffects
		value.some(|v| v.hasSideEffects )

	# for converting a real object into an ast-representation
	def self.wrap obj
		var attrs = []
		for own k,v of obj
			if v isa Array
				v = Arr.wrap(v)
			elif v:constructor == Object
				v = Obj.wrap(v)
			# if k isa String
			#	k = LIT(k)
			v = NODIFY(v)

			if k isa String
				k = Identifier.new(k)

			attrs.push(ObjAttr.new(k,v))
		return Obj.new(attrs)

	def toString
		"Obj"

export class ObjAttr < Node

	prop key
	prop value
	prop options

	def initialize key, value, defaults
		@traversed = no
		@key = key
		@value = value
		@dynamic = key isa Op
		@defaults = defaults
		self

	def visit stack, state
		# should probably traverse key as well, unless it is a dead simple identifier
		key.traverse
		value.traverse if value
		@defaults.traverse if @defaults
		
		let decl = state && state:declaring

		if key isa Ivar
			if !value
				key = Identifier.new(key.value)
				value = OP('.',scope__.context,key)
				if @defaults
					value = OP('=',value,@defaults)
					@defaults = null

		elif key isa Private
			if !value
				value = OP('.',scope__.context,key)
				key = Identifier.new(key.value)

		elif key isa Identifier
			# if state && state:declaring
			# 	key.variable = scope__.register(key.symbol,key)\
			# isnt this rather going to
			
			if !value
				if decl
					value = scope__.register(key.symbol,key, type: decl)
					stack.registerSemanticToken(key,value)

					if @defaults
						value = OP('=',value,@defaults)
						@defaults = null
				else
					value = scope__.lookup(key.symbol)
					
		
					
		self

	def js o
		let key = self.key
		let kjs

		# if key isa Identifier and String(key.@value)[0] == '@'
		# 	key = Ivar.new(key)

		if key isa IdentifierExpression or key isa SymbolIdentifier
			# streamline this interface
			kjs = key.asObjectKey
		elif key.isReserved
			kjs = "'{key.c}'"
		elif key isa Str and key.isValidIdentifier
			kjs = key.raw
		else
			kjs = key.c

		# var k = key.isReserved ? "'{key.c}'" : key.c

		if @defaults
			"{kjs} = {@defaults.c}"
		elif value
			"{kjs}: {value.c}"
		else
			"{kjs}"

	def hasSideEffects
		true

	def isPrimitive deep
		!@value or @value.isPrimitive(deep)


export class ObjRestAttr < ObjAttr

export class ArgsReference < Node

	# should register in this scope --
	def c
		"arguments"

# should be a separate Context or something
export class Self < Literal

	def initialize value
		@value = value

	def cache
		self

	def reference
		return self

	def visit
		scope__.context
		self

	def c
		var s = scope__
		M((s ? s.context.c : "this"),@value)

export class This < Self

	def cache
		self

	def reference
		self

	def visit
		self

	def c
		M("this",@value)

# OPERATORS

export class Op < Node

	prop op
	prop left
	prop right

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@opToken = o
		@op = o and o.@value or o
		
		if @op == 'and'
			@op = '&&'
		elif @op == 'or'
			@op = '||'
		elif @op == 'is'
			@op = '==='
		elif @op == 'isnt'
			@op = '!=='
		elif @op == 'not'
			@op = '!'

		@left = l
		@right = r
		return self

	def visit
		@right.traverse if @right and @right:traverse
		@left.traverse if @left and @left:traverse
		return self

	def isExpressable
		# what if right is a string?!?
		!right || right.isExpressable

	def startLoc
		let l = @left
		l and l:startLoc ? l.startLoc : super

	def js o
		var out = null
		var op = @op
		let opv = op

		var l = @left
		var r = @right
		
		if op == '!&'
			return "({C l} {M '&',@opToken} {C r})==0"
			
		elif op == '??'
			let ast = IF(OP('!=',l.cache,NULL), l, r, type: '?')
			ast.@scope.@systemscope = stack.scope
			# ast.traverse
			return ast.c(expression: yes)
			
		elif op == '|=?'
			return If.ternary(OP('!&',l,r.cache),
				Parens.new([OP('|=',l,r),TRUE]),
				FALSE
			).c
		
		elif op == '~=?'
			return If.ternary(OP('&',l,r.cache),
				Parens.new([OP('~=',l,r),TRUE]),
				FALSE
			).c
		
		elif op == '^=?'
			return OP('!!',OP('&',OP('^=',l,r.cache),r)).c
			
		elif op == '=?'
			r.cache
			return If.ternary(OP('!=',l,r),
				Parens.new([OP('=',l,r),TRUE]),
				FALSE
			).c

		l = l.c if l isa Node
		r = r.c if r isa Node
		

		if l && r
			out ||= "{l} {M op,@opToken} {r}"
		elif l
			out ||= "{M op,@opToken}{l}"

		out
		
	def isString
		@op == '+' and @left and @left.isString

	def shouldParenthesize
		@parens
		# option(:parens)

	def precedence
		10

	def consume node
		return super if isExpressable

		# TODO can rather use global caching?
		var tmpvar = scope__.declare(:tmp,null,system: yes)
		var clone = OP(op,left,null)
		var ast = right.consume(clone)
		ast.consume(node) if node
		return ast



export class ComparisonOp < Op

	def invert
		# are there other comparison ops?
		# what about a chain?
		var op = @op
		var pairs = [ "==","!=" , "===","!==" , ">","<=" , "<",">=" ]
		var idx = pairs.indexOf(op)
		idx += (idx % 2 ? -1 : 1)
		self.op = pairs[idx]
		@invert = !@invert
		self

	def c
		if left isa ComparisonOp
			left.right.cache
			OP('&&',left,OP(op,left.right,right)).c
		else
			super

	def js o
		var op = @op
		var l = @left
		var r = @right

		l = l.c if l isa Node
		r = r.c if r isa Node
		return "{l} {M op,@opToken} {r}"


export class UnaryOp < Op

	def invert
		if op == '!'
			return left
		else
			super # regular invert

	def isTruthy
		var val = AST.truthy(left)
		return val !== undefined ? (!val) : (undefined)

	def startLoc
		let l = (@left or @op)
		l and l:startLoc ? l.startLoc : @startLoc

	def js o
		var l = @left
		var r = @right
		var op = op

		if op == 'not'
			op = '!'

		if op == '!' or op == '!!'
			# l.@parens = yes
			var str = l.c
			var paren = l.shouldParenthesize(self)
			# FIXME this is a very hacky workaround. Need to handle all this
			# in the child instead, problems arise due to automatic caching
			unless (str.match(/^\!?([\w\.]+)$/) or l isa Parens or paren or l isa Access or l isa Call) and !str.match(/[\s\&\|]/)
				str = '(' + str + ')'
			# l.set(parens: yes) # sure?
			"{op}{str}"

		elif left
			"{l.c}{op}"

		else
			"{op}{r.c}"

	def normalize
		return self if op == '!'
		var node = (left || right).node
		# for property-accessors we need to rewrite the ast
		return self

	def consume node
		var norm = normalize
		norm == self ? super : norm.consume(node)

	def c
		var norm = normalize
		norm == self ? super : norm.c

export class InstanceOf < Op

	def js o
		# fix checks for String and Number

		if right isa Identifier or right isa VarOrAccess
			# WARN otherwise - what do we do? does not work with dynamic
			# classes etc? Should probably send to utility function isa$
			var name = AST.c(right.value)
			var obj = left.node
			# TODO also check for primitive-constructor
			if name in ['String','Number','Boolean']
				if STACK.tsc
					return "(typeof {obj.c}=='{name.toLowerCase}')"

				unless obj isa LocalVarAccess
					obj.cache
				# need a double check for these (cache left) - possibly
				return "(typeof {obj.c}=='{name.toLowerCase}'||{obj.c} instanceof {name})"

				# convert
		var out = "{left.c} instanceof {right.c}"

		# should this not happen in #c?
		out = helpers.parenthesize(out) if o.parent isa Op
		out

export class TypeOf < Op

	def js o
		"typeof {left.c}"

export class Delete < Op

	def js o
		# TODO this will execute calls several times if the path is not directly to an object
		# need to cache the receiver
		var l = left
		var tmp = scope__.temporary(self, pool: 'val')
		var o = OP('=',tmp,l)
		# FIXME
		return "({o.c},delete {l.c}, {tmp.c})" # oh well
		# var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
		# should parenthesize directly no?
		# ast.c

	def shouldParenthesize
		yes

export class In < Op

	def invert
		@invert = !@invert
		self

	def js o
		# var cond = @invert ? "== -1" : ">= 0"
		# var idx = Util.indexOf(left,right)
		var out = util.contains(left,right)
		"{@invert ? '!' : ''}{out.c}"



# ACCESS

export class Access < Op

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@op = o and o.@value or o
		@left = l
		@right = r
		return self

	
	def startLoc
		(@left or @right).startLoc

	def endLoc
		@right && @right.endLoc

	def clone left, right
		var ctor = self:constructor
		ctor.new(op,left,right)

	def js o
		var raw = null
		var lft = left
		var rgt = right

		if rgt isa Token
			rgt = Identifier.new(rgt)

		var ctx = (lft || scope__.context)
		var pre = ""
		var mark = ''

		unless @startLoc
			@startLoc = (lft or rgt).startLoc

		if lft isa Super and STACK.method and STACK.method.option('inExtension')
			return CALL(
				OP('.',scope__.context,'super$'),
				[rgt isa Identifier ? rgt.toStr : rgt]
			).c()

		if rgt isa Num or rgt isa SymbolIdentifier
			return ctx.c + "[" + rgt.c + "]"

		# is this right? Should not the index compile the brackets
		# or value is a symbol -- should be the same, no?
		if rgt isa Index and (rgt.value isa Str or rgt.value isa Symbol)
			rgt = rgt.value

		# TODO do the identifier-validation in a central place instead
		if rgt isa Str and rgt.isValidIdentifier
			raw = rgt.raw

		elif rgt isa Symbol and rgt.isValidIdentifier
			raw = rgt.raw

		elif rgt isa Identifier and rgt.isValidIdentifier
			# raw = M(rgt.c,rgt)
			raw = rgt.c

		if safechain and ctx
			ctx.cache(force: yes)
			pre = ctx.c + " && "
		

		# really?
		# var ctx = (left || scope__.context)
		var out = if raw
			# see if it needs quoting
			# need to check to see if it is legal
			ctx ? "{ctx.c}.{raw}" : raw
		else
			var r = rgt isa Node ? rgt.c(expression: yes) : rgt
			"{ctx.c}[{r}]"


		out = pre + out

		if pre
			out = "({out})"
		return out

	def visit
		left.traverse if left
		right.traverse if right
		@left ||= scope__.context
		return

	def isExpressable
		true

	def alias
		right isa Identifier ? right.alias : super()

	def safechain
		# right.safechain
		String(@op) == '..' or String(@op) == '?.'

	def cache o
		(right isa Ivar && !left) ? self : super(o)

	def shouldParenthesizeInTernary
		@parens or @cache


# Should change this to just refer directly to the variable? Or VarReference
export class LocalVarAccess < Access

	prop safechain

	def js o
		if right isa Variable and right.type == 'meth'
			return "{right.c}()" unless up isa Call

		right.c

	def variable
		right

	def cache o = {}
		super(o) if o:force
		self

	def alias
		variable.@alias or super()



export class PropertyAccess < Access

	def initialize o, l, r
		@traversed = no
		@invert = no
		@parens = no
		@expression = no # yes?
		@cache = null
		@op = o
		@left = l
		@right = r
		return self

	def visit
		@right.traverse if @right
		@left.traverse if @left
		return self

	# right in c we should possibly override
	# to create a call and regular access instead

	def js o
		# if var rec = receiver
		# 	var ast = CALL(OP('.',left,right),[]) # convert to ArgList or null
		# 	ast.receiver = rec
		# 	return ast.c

		var up = up
		# really need to fix this - for sure
		# should be possible for the function to remove this this instead?
		var js = "{super(o)}"
		return js


	def receiver
		if left isa Super
			SELF
		else
			null

export class IvarAccess < Access

	def visit
		@right.traverse if @right
		@left ? @left.traverse : scope__.context
		return self

	def cache
		# WARN hmm, this is not right... when accessing on another object it will need to be cached
		return self



export class IndexAccess < Access

	def cache o = {}
		return super if o:force
		right.cache
		self


export class VarOrAccess < ValueNode

	def initialize value
		# should rather call up to valuenode?
		@traversed 	= no
		@parens 	= no
		@value 		= value
		@identifier = value
		@token 		= value.@value
		@variable = null
		self

	def startLoc
		@token.startLoc

	def endLoc
		@token.endLoc

	# Shortcircuit traverse so that it is not added to the stack?!
	def visit stack, state
		# @identifier = value # this is not a real identifier?
		var variable
		var scope = scope__
		
		if state && state:declaring
			# console.log "VarOrAccess {@identifier}"
			variable = scope.register(value,self,type: state:declaring)

		variable ||= scope.lookup(value.symbol)

		if variable and variable isa GlobalReference
			let name = variable.name

			if stack.tsc
				@value = LIT(name)
			elif stack.isNode
				@value = LIT(scope.imba.c)
				if name != 'imba'
					@value = LIT("{scope.imba.c}.{name}")
			else
				@value = LIT(name)

			# "{root.symbolRef('#imba').c}"
			# console.log 'variable is global reference',variable.name,@value.c

		# does not really need to have a declarator already? -- tricky
		elif variable && variable.declarator
			# var decl = variable.declarator
			let vscope = variable.scope

			# if the variable is not initialized just yet and we are
			# in the same scope - we should not treat this as a var-lookup
			# ie.  var x = x would resolve to var x = this.x() if x
			# was not previously defined
			if vscope == scope and !variable.@initialized
				
				# here we need to check if the variable exists outside
				# if it does - we need to ensure that the inner variable does not collide
				let outerVar = scope.parent.lookup(value)
				if outerVar
					variable.@virtual = yes
					variable.@shadowing = outerVar
					variable = outerVar

			# should do this even if we are not in the same scope?
			# we only need to be in the same closure(!)

			if variable and variable.@initialized or (scope.closure != vscope.closure)
				@variable = variable
				variable.addReference(self)
				@value = variable # variable.accessor(self)
				@token.@variable = variable
				stack.registerSemanticToken(@token,variable)
				# if vscope isa RootScope and vscope.context != scope.context and variable.type == 'meth'
				# 	warn "calling method from root scope {value} is deprecated - see issue #112"
				if variable and @identifier.isInternal
					stack.registerSemanticToken(@token,@variable)
				return self
			# FIX
			# @value.safechain = safechain
		elif !@identifier.isCapitalized
			let ctx = scope.context
			if ctx isa RootScopeContext or ctx.isGlobalContext
				yes
			else
				@value = Access.new(".",ctx,@value)
				stack.registerSemanticToken(@token,'accessor')

		elif @identifier.isInternal
			@value = Access.new(".",scope.context,@value)

		return self

	# def c
	# 	@variable ? super() : @value.c() # M(@token.value,@token)
	# 	# M((@variable ? super() : value.c), @token)

	def js o
		return (@variable or @value).c()
		
		if var v = @variable
			return v.c()
		throw 'not implemented'

	def node
		@variable ? self : value

	def symbol
		@identifier.symbol
		# value and value.symbol

	def cache o = {}
		@variable ? (o:force ? super(o) : self) : value.cache(o)

	def decache
		@variable ? super() : value.decache
		self

	def dom
		value.dom

	def safechain
		@identifier.safechain

	def dump
		{ loc: loc }

	def loc
		var loc = @identifier.region
		return loc or [0,0]

	def region
		@identifier.region

	def shouldParenthesizeInTernary
		@cache or (@value and @value.@cache) or @parens

	def toString
		"VarOrAccess({value})"

	def toJSON
		{type: typeName, value: @identifier.toString}


export class VarReference < ValueNode

	prop variable
	prop declared
	prop type

	def initialize value, type
		if value isa VarOrAccess
			value = value.value
			@variable = null
		elif value isa Variable
			@variable = value
			value = ""

		# for now - this can happen
		super(value)
		@export = no
		@type = type and String(type)
		@declared = yes # just testing now


	def loc
		@value.region

	def declare
		self

	def consume node
		# really? the consumed node dissappear?
		@variable && @variable.autodeclare
		self

	def visit stack, state
		var vars = []
	
		@value.traverse(declaring: @type, variables: vars)

		if @value isa Identifier
			@value.@variable ||= scope__.register(@value.symbol,self,type: @type)
			vars.push(@value.@variable)
			stack.registerSemanticToken(@value,@variable)

		for variable in vars
			# should always be autodeclared?
			variable.@virtual = yes
			variable.autodeclare()

		return self
	
	def js o
		return @value.c()


# ASSIGN

export class Assign < Op

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@opToken = o
		@op = o and o.@value or o
		@left = l
		@right = r
		return self

	def isExpressable
		!right || right.isExpressable

	def isUsed
		# really?
		# if up is a block in general this should not be used -- since it should already have received implicit self?
		if up isa Block # && up.last != self
			return no
		return yes

	# FIXME optimize
	def visit
		var l = @left
		var r = @right
		
		if l isa VarOrAccess and r isa VarOrAccess and l.@identifier.symbol == r.@identifier.symbol
			@left = l = Access.new(".",scope__.context,l.@value)
		
		if r
			r.traverse(assignment: yes)
	
		if l
			l.traverse()

		return self

	def c o
		unless right.isExpressable
			if left isa VarReference and left.type == 'let'
				# when does this occur?
				# console.log 'unexpressable let var assignment'
				return Block.new([left,BR,right.consume(self)]).c(o)
			return right.consume(self).c(o)
		# testing this
		return super(o)

	def js o
		unless right.isExpressable
			p "Assign#js right is not expressable "
			# here this should be go out of the stack(!)
			# it should already be consumed?
			return right.consume(self).c
		var l = left.node
		var r = right

		if l isa Access and l.left isa Super
			if let m = STACK.method
				if m.option('inExtension')
					let key = l.right
					key = key.toStr if key isa Identifier
					# return "{scope.__context.c}.super$set('{l.right.c}')"
					let op = CALL(
						OP('.',scope__.context,'super$set'),
						[key,right]
					)
					return op.c(expression: true)
		# We are setting self(!)
		# TODO document functionality
		if l isa Self
			var ctx = scope__.context
			l = ctx.reference

		var lc = l.c
		var out = "{lc} {op} {right.c(expression: true)}"
		
		if let typ = (option(:datatype) or l.option(:datatype))
			if !(l isa VarReference)
				out = '/** @type {' + typ.c() + '} */\n' + out
			

		if l isa Obj
			out = "({out})"

		return out

	# FIXME op is a token? _FIX_
	# this (and similar cases) is broken when called from
	# another position in the stack, since 'up' is dynamic
	# should maybe freeze up?
	def shouldParenthesize par = up
		@parens or par isa Op && par.op != '='

	def consume node
		if node isa TagLike
			if right isa TagLike
				right.set(assign: left)
				return right.consume(node)
			else
				return self

		if isExpressable
			forceExpression
			return super(node)
		
		var ast = right.consume(self)
		return ast.consume(node)


export class PushAssign < Assign
	
	prop consumed
	
	def register node
		@consumed ||= []
		@consumed.push(node)
		self
		
	def js o
		"{left.c}.push({right.c})"

	def consume node
		return self

export class TagPushAssign < PushAssign

	def js o
		"{left.c}.push({right.c})"

	def consume node
		return self

export class ConditionalAssign < Assign

	def consume node
		normalize.consume(node)

	def normalize
		var l = left.node
		var ls = l

		if l isa Access

			if l.left
				l.left.cache
			ls = l.clone(l.left,l.right) # this should still be cached?

			if l isa PropertyAccess # correct now, to a certain degree
				l.cache

			if l isa IndexAccess or l.right isa IdentifierExpression
				l.right.cache

			# we should only cache the value itself if it is dynamic?
			# l.cache # cache the value as well -- we cannot use this in assigns them

		# some ops are less messy
		# need op to support consume then?
		var expr = right.isExpressable
		var ast = null
		# here we should use ast = if ...
		if expr && op == '||='
			ast = OP('||',l, OP('=',ls,right))
		elif expr && op == '&&='
			ast = OP('&&',l, OP('=',ls,right))
		else
			ast = IF(condition, OP('=',ls,right), l) # do we need a scope for these?
			ast.scope = null
			# drop the scope
			# touch scope -- should probably visit the whole thing?
			# ast.scope.visit
		ast.toExpression if ast.isExpressable
		ast


	def c
		# WARN what if we return the same?
		normalize.c

	def condition

		# use switch instead to cache op access
		if op == '?=' or op == '??='
			OP('==',left,NULL)
		elif op == '||='
			OP('!',left)
		elif op == '&&='
			left
		elif op == '!?='
			OP('!=',left,NULL)
		else
			left

	def js o
		var ast = IF(condition, OP('=',left,right), left)
		ast.scope = null # not sure about this
		ast.toExpression if ast.isExpressable # forced expression already
		return ast.c

export class CompoundAssign < Assign

	# FIXME can we merge consume and js?
	def consume node
		return super if isExpressable

		var ast = normalize
		return ast.consume(node) unless ast == self

		ast = right.consume(self)
		return ast.consume(node)

	def normalize
		var ln = left.node
		# we dont need to change this at all
		unless ln isa PropertyAccess
			return self

		ln.left.cache if ln.left
		# TODO FIXME we want to cache the context of the assignment
		var ast = OP('=',left,OP(op[0],left,right))
		ast.toExpression if ast.isExpressable

		return ast

	def c
		var ast = normalize
		return super if ast == self

		# otherwise it is important that we actually replace this node in the outer block
		# whenever we normalize and override c it is important that we can pass on caching
		# etc -- otherwise there WILL be issues.
		var up = STACK.current
		if up isa Block
			# an alternative would be to just pass
			up.replace(self,ast)
		ast.c


export class TypeAnnotation < Node
	
	def initialize value
		@parts = value
		# @parts.push(value) if value
		self
		
	def add item
		@parts.push(item)
	
	def startLoc
		@parts[0].startLoc

	def endLoc
		@parts[@parts:length - 1].endLoc

	def c
		M(@parts.map(|item| item.@value).join(""),self)
		
# IDENTIFIERS

# really need to clean this up
# Drop the token?
export class Identifier < Node

	prop safechain
	prop value
	prop variable

	def initialize value
		if value isa Token
			@startLoc = value.startLoc
		@value = load(value)
		@symbol = null

		if ("" + value).indexOf("?") >= 0
			@safechain = yes
		# @safechain = ("" + value).indexOf("?") >= 0
		self

	def isStatic
		yes

	def toRaw
		@value.@value or @value

	def add part
		IdentifierExpression.new(self).add(part)

	def references variable
		@value.@variable = variable if @value
		STACK.registerSemanticToken(@value,variable) if @value
		self

	def load v
		return (v isa Identifier ? v.value : v)

	def traverse
		# NODES.push(self)
		self

	def visit

		if @value isa Node
			# console.log "IDENTIFIER VALUE IS NODE"
			@value.traverse
		self

	def region
		[@value.@loc,@value.@loc + @value.@len]

	def startLoc
		@value and @value:startLoc ? @value.startLoc : null

	def endLoc
		@value and @value:endLoc ? @value.endLoc : null
		
	def loc
		[startLoc,endLoc]

	def isValidIdentifier
		yes

	def isReserved
		@value:reserved or RESERVED_TEST.test(String(@value))
		
	def isPredicate
		(/\?$/).test(String(@value))
	
	def isDangerous
		(/\!$/).test(String(@value))
		
	def isCapitalized
		(/^[A-Z]/).test(String(@value))
		
	def isInternal
		(/^\$/).test(String(@value))

	def symbol
		@symbol ||= AST.sym(value)

	def toString
		String(@value)

	def toStr
		return Str.new("'" + symbol + "'")
		
	def toAttrString
		return Str.new("'" + String(@value) + "'")

	def toJSON
		toString

	def alias
		AST.sym(@value)

	def js o
		@variable ? @variable.c() : symbol

	def c o
		let up = STACK.current
		return toStr.c if (up isa Util and !(up isa Util.Iterable)) # not all utils
		let out = js
		if OPTS:sourceMap and (!o or o:mark !== false)
			out = M(out, @token or @value)
		return out

	def dump
		{ loc: region }

	def namepath
		toString

	def shouldParenthesizeInTernary
		@parens or @cache
		
	def registerVariable type, scope = scope__
		@variable = scope.register(symbol,self,type: type)
		stack.registerSemanticToken(@value,@variable)
		return self
	
	def resolveVariable scope = scope__
		let variable = scope.lookup(symbol)
		@variable = variable
		stack.registerSemanticToken(@value,@variable)
		return self

export class DecoratorIdentifier < Identifier
	
	def symbol
		"decorator${@value.slice(1)}"
		
	def toString
		symbol

export class SymbolIdentifier < Identifier
	
	def c
		variable.c

	def variable
		@variable ||= scope__.root.symbolRef(@value.slice(0))

	def asObjectKey
		"[{c}]"

	def toString
		c

	def resolveVariable
		self

	def registerVariable
		self
		
export class MixinIdentifier < Identifier
	
	def symbol
		"mixin${@value.slice(1)}"
		
	def traverse o
		if @traversed
			return self
		unless @variable
			resolveVariable
		@traversed = yes
	
	def c o
		if o and (o:as == 'string' or o:as == 'substr')
			let flags = toFlags.map do |f| f isa Variable ? "$\{{f.c}\}" : f.raw
			let out = flags.join(' ')
			return o:as == 'string' ? "`{out}`" : out
			
		let up = STACK.current
		return toStr.c if (up isa Util and !(up isa Util.Iterable)) # not all utils
		let out = js
		if OPTS:sourceMap and (!o or o:mark !== false)
			out = M(out, @token or @value)
		return out

		
	def toString
		symbol
		
	def toFlagName
		# look for variable etc
		symbol
		
	def toFlags
		return @parts if @parts
		traverse
		let v = @variable
		let parts = []
		let part = v
		
		while part
			if part.@declarator isa StyleRuleSet
				parts.push(STR(part.@declarator.@name))
			else
				parts.push(part)

			part = part.@parent
		
		# for part in vars
		# 	if part.@declarator isa StyleRuleSet
		# 		parts.push(STR(v.@declarator.@name))
		# console.log 'resolvedFlagName',parts
		return @parts = parts
		
		if v and v.@declarator isa StyleRuleSet
			return v.@declarator.@name
		return null

export class Private < Identifier

	def symbol
		@symbol ||= AST.sym('__' + value)

	def add part
		IdentifierExpression.new(value).add(part).set(prefix: '__', private: yes)

	# def c
	# 	let up = STACK.current
	# 	return toStr.c if up isa Util
	# 	return '' + symbol


export class TagIdRef < ValueNode

	def initialize v
		@value = v isa Identifier ? v.value : v
		self

	def js
		"{scope__.imba.c}.getElementById('{value.c}')"


# This is not an identifier - it is really a string
# Is this not a literal?

# FIXME Rename to IvarLiteral? or simply Literal with type Ivar
export class Ivar < Identifier

	def initialize v
		@value = v isa Identifier ? v.value : v
		self

	def name
		helpers.dashToCamelCase(@value).replace(/^[\#]/,'')
		# value.c.camelCase.replace(/^@/,'')

	def alias
		name

	# the @ should possibly be gone from the start?
	def js o
		return symbol


export class Decorator < ValueNode

	def name
		@name ||= @value.js
	
	def visit
		@variable = scope__.lookup(name)
		@value.@variable ||= @variable

		@call.traverse if @call
		if option(:params)
			@params = option(:params)
			@params.traverse

		if let block = up
			block.@decorators ||= []
			block.@decorators.push(self)

	def c 
		# should return other places as well...
		return if STACK.current isa ClassBody

		let out = @value.c
		
		if @params
			out += ".bind([{@params.c(expression: yes)}])"
		else
			out += ".bind([])"
		return out

# Ambiguous - We need to be consistent about Const vs ConstAccess
# Becomes more important when we implement typeinference and code-analysis
export class Const < Identifier

	def symbol
		# console.log "Identifier#symbol {value}"
		@symbol ||= AST.sym(value)

	def js o
		@variable ? @variable.c : symbol

	def traverse
		if @traversed
			return self

		@traversed = true
		var curr = STACK.current
		if !(curr isa Access) or curr.left == self
			if symbol == "Imba"
				@variable = scope__.imba
			else
				@variable = scope__.lookup(value)
		self

	def c
		if option(:export)
			"exports.{@value} = " + js
		else
			super


export class TagTypeIdentifier < Identifier

	prop name
	prop ns

	def initialize value
		@token = value
		@value = load(value)
		self

	def startLoc
		@token?.startLoc

	def endLoc
		@token?.endLoc
		

	def load val
		@str = ("" + val)
		var parts = @str.split(":")
		@raw = val
		@name = parts.pop
		@ns = parts.shift # if any?
		return @str
		
	def traverse o
		if @traversed
			return self
		# NODES.push(self)
		@traversed = yes
		if isClass
			if o and o:declaring
				registerVariable('const',o:declscope or STACK.scope)
				if @variable
					@variable.value = o:declaring
			else
				resolveVariable
		self

	def js o
		return "'" + toNodeName + "'"

	def c
		js

	def func
		var name = @name.replace(/-/g,'_').replace(/\#/,'')
		name += "${@ns.toLowerCase}" if @ns
		name

	def nativeCreateNode
		let doc = scope__.root.document.c
		if isSVG
			CALL(LIT("{doc}.createElementNS"),[STR("http://www.w3.org/2000/svg"),STR(name)])
		else
			CALL(LIT("{doc}.createElement"),[STR(name)])

	def isClass
		!!@str.match(/^[A-Z]/)
		
	def isNative
		!@ns and TAG_TYPES.HTML.indexOf(@str) >= 0

	def isNativeSVG
		@ns == 'svg' and TAG_TYPES.SVG.indexOf(@str) >= 0

	def isSVG
		@ns == 'svg' or (!isNative and !@ns and TAG_NAMES["svg_{@str}"]) or isAsset # TAG_TYPES.SVG.indexOf(@str) >= 0

	def isAsset
		!!@str.match(/^svg\-/)

	def toAssetName
		isAsset ? @str.slice(4) : null
		
	def symbol
		@str

	def isCustom
		!isNative and !isNativeSVG

	def isComponent
		!isNative and !isNativeSVG
	
	def isSimpleNative
		isNative and !(/input|textarea|select|form|iframe/).test(@str)

	def toFunctionalType
		LIT(@str)
		
	def toSelector
		toNodeName
		
	def resolveVariable scope = scope__
		let variable = scope__.lookup(@str)
		if @variable = variable
			stack.registerSemanticToken(@value,@variable)
		return self

	

	def toClassName
		let str = @str
		if str == 'element'
			return 'Element'
		elif str == 'svg:element'
			return 'SVGElement'
		elif str == 'htmlelement'
			return 'HTMLElement'
		elif str == 'fragment'
			return 'DocumentFragment'

		let match = TAG_NAMES[isSVG ? "svg_{@name}" : @name]
		return match:name if match
			
		if @str == 'fragment'
			return 'DocumentFragment'
		elif isClass
			return @str
		else
			return helpers.pascalCase(@str + '-component')
			
	def toNodeName
		if isClass
			@nodeName ||= helpers.dasherize(@str + '-' + sourceId)
		else
			@str

	def toTypeArgument
		if @variable
			@variable.c
		else
			name

	def id
		var m = @str.match(/\#([\w\-\d\_]+)\b/)
		m ? m[1] : null


	def flag
		"_" + name.replace(/--/g,'_').toLowerCase

	def sel
		".{flag}" # + name.replace(/-/g,'_').toLowerCase

	def string
		value

	def toString
		value

export class InterpolatedIdentifier < ValueNode
	def js
		"[{value.c}]"

export class Argvar < ValueNode

	def c
		# NEXT -- global.parseInt or Number.parseInt (better)
		var v = parseInt(String(value))
		# FIXME Not needed anymore? I think the lexer handles this
		return "arguments" if v == 0

		var s = scope__
		# params need to go up to the closeste method-scope
		var par = s.params.at(v - 1,yes)
		"{AST.c(par.name)}" # c


# CALL


		
export class DoPlaceholder < Node

export class Call < Node

	prop callee
	prop receiver
	prop args
	prop block

	# def m
	# 	console.log "called Call.m {@callee} ({startLoc} - {@callee.startLoc}) [{endLoc}]"
	# 	super

	def initialize callee, args, opexists
		@traversed = no
		@expression = no
		@parens = no
		@cache = null
		@receiver = null
		@opexists = opexists
		# some axioms that share the same syntax as calls will be redirected from here
		if callee isa BangCall
			callee = callee.@callee

		if callee isa VarOrAccess
			var str = callee.value.symbol
			if str == 'new'
				console.log 'calling'
			if str == 'extern'
				callee.value.value.@type = 'EXTERN'
				return ExternDeclaration.new(args)
			if str == 'tag'
				# console.log "ERROR - access args by some method"
				return TagWrapper.new(args and args:index ? args.index(0) : args[0])
			if str == 'export'
				return Export.new(args)

		@callee = callee	
		@args = args or ArgList.new([])

		if args isa Array
			@args = ArgList.new(args)
			
		if callee isa Decorator
			callee.@call = self
			return callee

		return self
		
	def loc
		@callee.loc

	def visit
		args.traverse
		callee.traverse
		# if the callee is a PropertyAccess - better to immediately change it

		@block && @block.traverse

	def addBlock block
		var pos = @args.filter(|n,i| n isa DoPlaceholder )[0]
		pos ? args.replace(pos,block) : args.push(block)
		self

	def receiver
		@receiver ||= (callee isa Access && callee.left || NULL)

	# check if all arguments are expressions - otherwise we have an issue

	def safechain
		callee.safechain # really?

	def shouldParenthesizeInTernary
		@parens or safechain or @cache

	def startLoc
		@startLoc or @callee and @callee:startLoc ? @callee.startLoc : 0

	def endLoc
		@endLoc or (@args and @args.endLoc) or @callee.endLoc

	def js o
		var opt = expression: yes
		var rec = null
		# var args = AST.compact(args) # really?
		var args = args

		# drop this?

		var splat = args.some do |v| v isa Splat

		var out = null
		var lft = null
		var rgt = null
		var wrap = null

		var callee = @callee = @callee.node # drop the var or access?

		# if callee isa Call && callee.safechain
		#	yes

		if callee isa Access
			lft = callee.left
			rgt = callee.right

		if callee isa Super
			if let m = STACK.method
				# console.log "in method {m} {m.name} {m.option('inExtension')}"
				if m.option('inExtension')
					callee = OP('.',callee,m.name)
					@receiver = scope__.context
					# callee = @callee = OP('.',scope__.context,'super$')
					# args.unshift(m.name.toStr) # = ArgList.new
			# @receiver = scope__.context
			self
			# return "supercall"

		# never call the property-access directly?
		if callee isa PropertyAccess # && rec = callee.receiver
			@receiver = callee.receiver
			callee = @callee = Access.new(callee.op,callee.left,callee.right)

		if rgt isa Identifier and rgt.value == 'assert' and !splat and false
			let arg = args.first
			arg.option(:assertion,yes)
			args.@nodes[0] = AssertionNode.new(arg)
			# console.log "Special assert call!! {arg.c}",arg isa Op

			# rewrite a.len(..) to len$(a)

		if callee.safechain
			var isfn = Util.IsFunction.new([callee])
			wrap = ["{isfn.c}  &&  ",""]
			callee = OP('.',callee.left,callee.right)
			# callee should already be cached now -

		# should just force expression from the start, no?
		if @receiver
			# quick workaround
			@receiver.cache unless @receiver isa ScopeContext
			args.unshift(receiver)
			# should rather rewrite to a new call?
			out = "{callee.c(expression: yes)}.call({args.c(expression: yes,mark: false)})"

		else
			out = "{callee.c(expression: yes)}({args.c(expression: yes,mark: false)})"

		if wrap
			# we set the cachevar inside
			if @cache
				@cache:manual = yes
				out = "({cachevar.c}={out})"

			out = [wrap[0],out,wrap[1]].join("")

		return out

export class BangCall < Call

export class Instantiation < ValueNode

	def js o
		"{M('new',keyword)} {value.c}"

export class New < Call

	# def startLoc
	# 	keyword ? keyword.startLoc : super
	
	def visit
		keyword.warn 'Value.new is deprecated - use new Value'
		super

	def endLoc
		keyword and keyword.endLoc or super

	def startLoc
		null

	def js o
		var target = callee

		while target isa Access
			let left = target.left

			if (left isa PropertyAccess) or (left isa VarOrAccess)
				callee.@parens = yes
				break

			target = left

		# var out = "{M(keyword or 'new',keyword)} {callee.c}"
		var out = "{M('new',keyword)} {M(callee.c,callee)}"
		out += '()' unless (o.parent isa Call or o.parent isa BangCall)
		out


export class ExternDeclaration < ListNode

	def visit
		nodes = map do |item| item.node # drop var or access really
		# only in global scope?
		var root = scope__
		for item in nodes
			var variable = root.register item.symbol, item, type: 'global'
			variable.addReference(item)
		self

	def c
		"// externs"


# FLOW

export class ControlFlow < Node

	def loc
		@body ? @body.loc : [0,0]

export class ControlFlowStatement < ControlFlow

	def isExpressable
		no


export class If < ControlFlow

	prop test
	prop body
	prop alt
	prop scope
	prop prevIf

	def self.ternary cond, body, alt
		# prefer to compile it this way as well
		var obj = If.new(cond, Block.new([body]), type: '?')
		obj.addElse Block.new([alt])
		return obj

	def addElse add
		if alt && alt isa If
			alt.addElse(add)
		else
			self.alt = add
			if add isa If
				add.prevIf = self
		self

	def initialize cond, body, o = {}
		setup
		@test = cond # (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
		@body = body
		@alt  = null
		@type = o:type
		invert if @type == 'unless'
		@scope = IfScope.new(self)
		self

	def loc
		@loc ||= [@type ? @type.@loc : 0,body.loc[1]]

	def invert
		if @test isa ComparisonOp
			@test = @test.invert
		else
			@test = UnaryOp.new('!',@test,null)

	def visit stack
		var alt = alt

		@scope.visit if @scope
		test.traverse if test
		
		@tag = stack.@tag

		# console.log "vars in if",Object.keys(@scope.varmap)
		# TODO deal with variable scope
		for own name, variable of @scope.varmap
			if variable.type == 'let'
				# console.log "variable virtualize"
				variable.@virtual = yes
				variable.autodeclare()

		# the let-variables declared in if(*test*) should be
		# local to the inner scope, but will technically be
		# declared in the outer scope. Must get unique name

		if !stack.isAnalyzing and !stack.tsc
			@pretest = AST.truthy(test)

			if @pretest === true
				# only collapse if condition includes compiletime flags?
				alt = @alt = null
				if test isa EnvFlag
					@preunwrap = true

			elif @pretest === false
				loc # cache location before removing body
				body = null

		body.traverse if body

		# should skip the scope in alt.
		if alt
			STACK.pop(self)
			alt.@scope ||= BlockScope.new(alt)
			alt.traverse
			STACK.push(self)

		# force it as expression?
		toExpression if @type == '?' and isExpressable
		self


	def js o
		var body = body
		# would possibly want to look up / out
		var brace = braces: yes, indent: yes

		if @pretest === true and @preunwrap
			# what if it is inside expression?
			let js = body ? body.c(braces: !!prevIf) : 'true'

			unless prevIf
				js = helpers.normalizeIndentation(js)

			if o.isExpression
				js = '(' + js + ')'

			return js

		elif @pretest === false and false
			alt.prevIf = prevIf if alt isa If
			let js = alt ? alt.c(braces: !!prevIf) : ''

			unless prevIf
				js = helpers.normalizeIndentation(js)

			return js
		

		if o.isExpression

			if test?.shouldParenthesizeInTernary
				test.@parens = yes

			var cond = test.c(expression: yes) # the condition is always an expression

			var code = body ? body.c : 'true' # (braces: yes)

			if body and body.shouldParenthesizeInTernary
				code = '(' + code + ')' # if code.indexOf(',') >= 0

			if alt
				var altbody = alt.c
				if alt.shouldParenthesizeInTernary
					altbody = '(' + altbody + ')'

				return "{cond} ? {code} : {altbody}"
			else
				# again - we need a better way to decide what needs parens
				# maybe better if we rewrite this to an OP('&&'), and put
				# the parens logic there
				# cond should possibly have parens - but where do we decide?
				if @tag
					return "{cond} ? {code} : void(0)"
				else
					return "{cond} && {code}"
		else
			# if there is only a single item - and it is an expression?
			var code = null
			var cond = test.c(expression: yes) # the condition is always an expression

			# if body.count == 1 # dont indent by ourselves?

			if body isa Block and body.count == 1 and !(body.first isa LoopFlowStatement)
				body = body.first

			# if body.count == 1
			#	p "one item only!"
			#	body = body.first

			code = body ? body.c(braces: yes) : '{}' # (braces: yes)

			# don't wrap if it is only a single expression?
			var out = "{M 'if',@type} ({cond}) " + code # ' {' + code + '}' # '{' + code + '}'
			out += " else {alt.c(alt isa If ? {} : brace)}" if alt
			out


	def shouldParenthesize
		!!@parens

	def consume node
		if node isa TagLike
			# now we are reconsuming this
			node.flag(F.TAG_HAS_BRANCHES)
				
			if node.body == self
				let branches = @body ? [@body] : []
				let alt = @alt
				
				while alt isa If
					branches.push(alt.@body) if alt.@body
					alt = alt.@alt
				
				if alt
					branches.push(alt)
				
				for block,i in branches
					node.@branches.push([])
					block.consume(node)

				return self
				
			if node isa TagLoopFragment
				if @body
					@body = @body.consume(node)

				if @alt
					@alt = @alt.consume(node)
				return self
			else
				return node.register(self)

			return self

		if node isa TagPushAssign or node isa TagFragment
			node.register(self)
			@body = @body.consume(node) if @body
			@alt = @alt.consume(node) if @alt
			return self

		# special case for If created from conditional assign as well?
		# @type == '?' and
		# ideally we dont really want to make any expression like this by default
		var isRet = node isa Return

		# might have been forced to expression already
		# if it was originally a ternary - why not
		if @expression or ((!isRet or @type == '?') and isExpressable)
			toExpression # mark as expression(!) - is this needed?
			return super(node)
		else
			@body = @body.consume(node) if @body
			@alt = @alt.consume(node) if @alt
		self


	def isExpressable
		# process:stdout.write 'x'
		var exp = (!body || body.isExpressable) && (!alt || alt.isExpressable)
		return exp



export class Loop < Statement


	prop scope
	prop options
	prop body
	prop catcher
	prop elseBody

	def loc
		var a = @options:keyword
		var b = @body

		if a and b
			# FIXME does not support POST_ variants yet
			[a.@loc,b.loc[1]]
		else
			[0,0]

	def initialize options = {}
		@traversed = no
		@options = options
		@body = null
		self

	def set obj
		@options ||= {}
		var keys = Object.keys(obj)
		for k in keys
			@options[k] = obj[k]
		self


	def addBody body
		self.body = AST.blk(body)
		self

	def addElse block
		self.elseBody = block
		self

	def isReactive
		@tag and @tag.fragment.isReactive

	def c o

		var s = stack
		var curr = s.current
		
		if stack.isExpression or isExpression
			# what the inner one should not be an expression though?
			# this will resut in an infinite loop, no?!?
			scope.closeScope
			
			var ast = CALL(FN([],[self]),[])
			return ast.c o

		elif stack.current isa Block or (s.up isa Block and s.current.@consumer == self)
			super.c o
		elif @tag
			super.c 0
		else
			
			scope.closeScope
			var ast = CALL(FN([],[self]),[])
			# scope.context.reference
			return ast.c o
			# need to wrap in function



export class While < Loop

	prop test

	def initialize test, opts
		@traversed = no
		@test = test
		@options = opts or {}
		@scope = WhileScope.new(self)
		# set(opts) if opts
		if option(:invert)
			# "invert test for while {@test}"
			@test = test.invert
		# invert the test


	def visit
		scope.visit
		test.traverse if test
		body.traverse if body

	def loc
		var o = @options
		helpers.unionOfLocations(o:keyword,@body,o:guard,@test)

	# TODO BUG -- when we declare a var like: while var y = ...
	# the variable will be declared in the WhileScope which never
	# force-declares the inner variables in the scope

	def consume node

		# This is never expressable, but at some point
		# we might want to wrap it in a function (like CS)
		return super if isExpressable
		var reuse = no
		# WARN Optimization - might have untended side-effects
		# if we are assigning directly to a local variable, we simply
		# use said variable for the inner res
		# if reuse
		# 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
		# 	node = null
		# 	p "consume variable declarator!?".cyan
		# else
		# declare the variable we will use to soak up results
		# TODO Use a special vartype for this?
		var resvar = scope.declare(:res,Arr.new([]),system: yes)
		# WHAT -- fix this --
		@catcher = PushAssign.new("push",resvar,null) # the value is not preset # what
		body.consume(@catcher) # should still return the same body

		# scope vars must not be compiled before this -- this is important
		var ast = Block.new([self,resvar.accessor]) # should be varaccess instead?
		ast.consume(node)
		# NOTE Here we can find a way to know wheter or not we even need to
		# return the resvar. Often it will not be needed
		# FIXME what happens if there is no node?!?


	def js o
		var out = "while ({test.c(expression: yes)})" + body.c(braces: yes, indent: yes) # .wrap

		if scope.vars.count > 0
			
			out = scope.vars.c + ';' + out
			# [scope.vars.c,out]
		out



# This should define an open scope
# should rather
export class For < Loop

	def initialize o = {}
		@traversed = no
		@options = o
		@scope = ForScope.new(self)
		@catcher = null

	def loc
		var o = @options
		helpers.unionOfLocations(o:keyword,@body,o:guard,o:step,o:source)
	
	def ref
		@ref || "{@tag.fragment.cvar}.{oid}"

	def visit stack
		scope.visit

		var parent = stack.@tag

		options:source.traverse # what about awakening the vars here?
		
		# add guard to body
		if options:guard
			var op = IF(options:guard.invert,Block.wrap([ContinueStatement.new("continue")]))
			body.unshift(op,BR)

		declare
			
		# here add the things to declare
		
		if parent
			# TODO remove
			@tag = parent
			stack.@tag = self
			@level = (@tag && @tag.@level or 0) + 1

		body.traverse
		stack.@tag = parent
		self

	def isBare src
		src and src.@variable and src.@variable.@isArray

	def declare
		var o = options
		var scope = scope
		var src  = o:source
		var vars = o[:vars] = {}
		var oi   = o:index

		var bare = isBare(src)

		# if the name parameter is array or object we move this inside?

		# what about a range where we also include an index?
		if src isa Range
			
			let from = src.left
			let to = src.right
			let dynamic = from !isa Num or to !isa Num

			if to isa Num
				vars:len = to
			else
				# vars:len = scope.vars.push(vars:index.assignment(src.left))
				# vars:len = to.cache(force: yes, pool: 'len').predeclare
				vars:len = scope.declare('len',to,type: 'let')
				# to.cache(force: yes, pool: 'len').predeclare
				
			# scope.vars.push(vars:index.assignment(src.left))
			vars:value = scope.declare(o:name,from,type: 'let')
			vars:value.addReference(o:name) if o:name
			
			if o:index
				vars:index = scope.declare(o:index,0,type: 'let')
				vars:index.addReference(o:index)
			else
				vars:index = vars:value
				
			if dynamic
				vars:diff = scope.declare('rd',OP('-',vars:len,vars:value),type: 'let')

		else
			if oi
				vars:index = scope.declare(oi,0,type: 'let')
			else
				vars:index = scope.declare('i',Num.new(0),system: yes, type: 'let', pool: 'counter')

			vars:source = bare ? src : scope.declare('items',util.iterable(src),system: yes, type: 'let', pool: 'iter')
			vars:len = scope.declare('len',util.len(vars:source),type: 'let', pool: 'len', system: yes)
			
			if o:name
				body.unshift(VarDeclaration.new(o:name,OP('.',vars:source,vars:index),'let'),BR)
				
			vars:index.addReference(oi) if oi

		return self

	def consume node
		if node isa TagLike
			return node.register(self)

		if isExpressable
			return super

		if @resvar
			var ast = Block.new([self,BR,@resvar.accessor])
			ast.consume(node)
			return ast

		var resvar = null
		var reuseable = no
		var assignee = null
		
		# this should be autodeclared no?
		resvar = @resvar ||= scope.register(:res,null,system: yes, type: 'var')

		@catcher = PushAssign.new("push",resvar,null) # the value is not preset
		let resval = Arr.new([])
		body.consume(@catcher) # should still return the same body
		resvar.autodeclare() # only if it is a system variable?
		
		if node isa VarDeclaration or node isa Assign
			node.right = resvar.accessor
			# let block = [self,BR,node]
			return Block.new([
				OP('=',resvar,resval)
				BR,
				self,
				BR,
				node
			])

		elif node
			let block = [OP('=',resvar,resval),BR,self,BR,resvar.accessor.consume(node)]
			return Block.new(block)

		return self

	def js o
		var vars = options:vars
		var idx = vars:index
		var val = vars:value
		var src = options:source
		
		var cond
		var final

		if src isa Range
			let a = src.left
			let b = src.right
			let inc = src.inclusive

			cond = OP(inc ? '<=' : '<',val,vars:len)
			final = OP('++',val)

			if vars:diff
				cond = If.ternary( OP('>',vars:diff,Num.new(0)), cond, OP(inc ? '>=' : '>',val,vars:len))
				final = If.ternary( OP('>',vars:diff,Num.new(0)),OP('++',val),OP('--',val))
			
			if idx and idx != val
				final = ExpressionBlock.new([final,OP('++',idx)])
			
		else
			cond = OP('<',idx,vars:len)

			if options:step
				final = OP('=',idx,OP('+',idx,options:step))
			else
				final = OP('++',idx)

		var before = ""
		var after = ""

		var code = body.c(braces: yes, indent: yes)
		var head = "{M('for',keyword)} ({scope.vars.c}; {cond.c(expression: yes)}; {final.c(expression: yes)}) "
		
		return before + head + code + after



export class ForIn < For

export class ForOf < For
	prop source

	def declare
		var o = options
		var vars = o:vars = {}
		var k
		var v

		# possibly proxy the index-variable?

		if o:own
			vars:source = o:source.@variable || scope.declare('o',o:source, system: true, type: 'let')
			o:value = o:index

			var i = vars:index = scope.declare('i',Num.new(0),system: yes, type: 'let', pool: 'counter')
			# systemvariable -- should not really be added to the map
			var keys = vars:keys = scope.declare('keys',Util.keys(vars:source.accessor),system: yes, type: 'let') # the outer one should resolve first
			var l = vars:len = scope.declare('l',Util.len(keys.accessor),system: yes, type: 'let')
			k = vars:key = scope.declare(o:name,null,type: 'let') # scope.declare(o:name,null,system: yes)
			
			if o:value isa Obj or o:value isa Arr
				body.unshift(VarDeclaration.new(o:value,OP('.',vars:source,k),'let'),BR)
				vars:value = null
			elif o:value
				v = vars:value = scope.declare(o:value,null,let: yes, type: 'let')
		
		else
			source = vars:source = STACK.tsc ? o:source : util.iterable(o:source)
			vars:value = o:value = o:name # need to visit these to declare them
			o:value.traverse(declaring: 'let')
			
			if o:value isa Identifier
				# v = vars:value = scope.declare(o:name,null,let: yes, type: 'let')
				o:value.@variable ||= scope__.register(o:value.symbol,o:value,type: 'let')
				STACK.registerSemanticToken(o:value)
			
			# need to declare this variable outside the for of
			if o:index
				vars:counter = scope.parent.temporary(null,{},"{o:index}$")
				body.unshift(VarDeclaration.new(o:index,OP('++',vars:counter),'let'),BR)
				self

		# TODO use util - why add references already? Ah -- this is for the highlighting
		v.addReference(o:index) if v and o:index
		k.addReference(o:name) if k and o:name

		self

	def js o
		var vars = options:vars
		var osrc = options:source
		var src = vars:source
		var k = vars:key
		var v = vars:value
		var i = vars:index

		var code
		
		if options:own
			# FIXME are we sure about this?
			if v and v.refcount > 0
				body.unshift(OP('=',v,OP('.',src,k)))

			body.unshift(OP('=',k,OP('.',vars:keys,i)))
			code = body.c(indent: yes, braces: yes) # .wrap
			var head = "{M('for',keyword)} ({scope.vars.c}; {OP('<',i,vars:len).c}; {OP('++',i).c})"
			return head + code

		else
			# compile to a naive for of loop
			code = scope.c(braces: yes, indent: yes)
			# let inCode = osrc.@variable ? src : (OP('=',src,osrc))
			# it is really important that this is a treated as a statement
			let js = "{M('for',keyword)} (let {v.c} of {src.c(expression: yes)})" + code
			if vars:counter
				js = "{vars:counter} = 0; {js}"
			return js

	def head
		var v = options:vars
		# skipping head?
		[
			OP('=',v:key,OP('.',v:keys,v:index))
			OP('=',v:value,OP('.',v:source,v:key)) if v:value
		]

# NO NEED?
export class Begin < Block


	def initialize body
		@nodes = AST.blk(body).nodes


	def shouldParenthesize
		isExpression



export class Switch < ControlFlowStatement


	prop source
	prop cases
	prop fallback


	def initialize a,b,c
		@traversed = no
		@source = a
		@cases = b
		@fallback = c


	def visit
		c.traverse for c in cases
		fallback.traverse if fallback
		source.traverse if source
		return


	def consume node
		if node isa TagLike
			if node.body == self
				let branches = @cases.slice(0).concat([@fallback])
				for block,i in branches when block
					node.@branches.push([])
					block.consume(node)
				return self
			return node.register(self)
		# TODO work inside tags (like loops)
		@cases = @cases.map(|item| item.consume(node))
		@fallback = @fallback.consume(node) if @fallback
		self

	def c o
		if stack.isExpression or isExpression
			var ast = CALL(FN([],[self]),[])
			return ast.c o

		super.c(o)


	def js o
		var body = []

		for part in cases
			part.autobreak
			body.push(part)

		if fallback
			body.push("default:\n" + fallback.c(indent: yes))

		"switch ({source.c}) " + helpers.bracketize(AST.cary(body).join("\n"),yes)



export class SwitchCase < ControlFlowStatement


	prop test
	prop body


	def initialize test, body
		@traversed = no
		@test = test
		@body = AST.blk(body)
		@scope = BlockScope.new(self)

	def visit
		scope__.visit
		body.traverse

	def consume node
		body.consume(node)
		self


	def autobreak
		body.push(BreakStatement.new) unless body.last isa BreakStatement
		self


	def js o
		@test = [@test] unless @test isa Array
		var cases = @test.map do |item| "case {item.c}: "
		cases.join("\n") + body.c(indent: yes, braces: yes)



export class Try < ControlFlowStatement


	prop body
	# prop ncatch
	# prop nfinally

	def initialize body, c, f
		@traversed = no
		@body = AST.blk(body)
		@catch = c
		@finally = f


	def consume node
		@body = @body.consume(node)
		@catch = @catch.consume(node) if @catch
		@finally = @finally.consume(node) if @finally
		self


	def visit
		@body.traverse
		@catch.traverse if @catch
		@finally.traverse if @finally
		# no blocks - add an empty catch


	def js o
		var out = "try " + body.c(braces: yes, indent: yes)
		out += " " + @catch.c if @catch
		out += " " + @finally.c if @finally

		unless @catch or @finally
			out += " catch (e) \{ \}"
		out += ";"
		out



export class Catch < ControlFlowStatement

	prop body

	def initialize body, varname
		@traversed = no
		@body = AST.blk(body or [])
		@scope = CatchScope.new(self)
		@varname = varname
		self

	def consume node
		@body = @body.consume(node)
		self


	def visit
		@scope.visit
		@variable = @scope.register(@varname,self,pool: 'catchvar')
		@body.traverse


	def js o
		# only indent if indented by default?
		"catch ({@variable.c}) " + @body.c(braces: yes, indent: yes)


# repeating myself.. don't deal with it until we move to compact tuple-args
# for all astnodes


export class Finally < ControlFlowStatement

	def initialize body
		@traversed = no
		@body = AST.blk(body or [])


	def visit
		@body.traverse


	def consume node
		# swallow silently
		self


	def js o
		"finally " + @body.c(braces: yes, indent: yes)


# RANGE

export class Range < Op

	def inclusive
		op == '..'

	def c
		"range"


export class Splat < ValueNode

	def js o
		return "...{value.c}"

		var par = stack.parent
		if par isa ArgList or par isa Arr
			"Array.from({value.c})"
		else
			p "what is the parent? {par}"
			"SPLAT"

	def node
		value


# TAGS


export class IdentifierExpression < Node
	prop single
	
	def self.wrap node
		return node
		node isa self ? node : self.new(node)

	def initialize value
		super
		@static = yes
		@nodes = [@single = value]

	def add part
		@nodes.push(part)
		@single = null
		self

	def isPrimitive
		@single and @single isa Token

	def isStatic
		isPrimitive

	def visit
		for node in @nodes when node isa Node
			node.traverse
		self

	def asObjectKey
		if isPrimitive
			"{@single.c()}"
		elif @single
			"[{@single.c()}]"
		else
			"[{asString}]"

	def startLoc
		let n = @nodes[0]
		n?.startLoc

	def endLoc
		let n = @nodes[@nodes:length - 1]
		n?.endLoc

	def asIdentifier
		@single ? "[{@single.c()}]" : "[{asString}]"

	def asString
		# what if a part is a string?	
		let s = '`'
		if option(:prefix)
			s += option(:prefix)
		for node in @nodes
			if node isa Token
				s += node.value
			else
				s += '${'
				s += node.c()
				s += '}'
		s += '`'
		return s

	def toRaw
		@single ? @single.c : ''

	def toString
		toRaw

	def js s, o = {}
		if o:as == 'string' or s.parent isa Util
			return asString
		elif o:as == 'key'
			return asObjectKey
		elif o:as == 'access'
			yes
		elif @single and @single isa Node
			return @single.c(o)
		else
			asString

export class TagPart < Node

	prop name
	prop value
	prop params
	
	def initialize value, owner
		@name = load(value)
		@tag = owner
		@chain = []
		@special = no
		@params = null
		self

	def load value
		value
		
	def isSpecial
		@special
		
	def visit
		@chain.map(|v| v.traverse )
		@value.traverse if @value
		@name.traverse if @name:traverse
		self
	
	def quoted
		@quoted ||= (@name isa IdentifierExpression ? @name.asString : helpers.singlequote(@name))
	
	def valueIsStatic
		!value or value.isPrimitive or (value isa Func and !value.nonlocals)

	def isStatic
		valueIsStatic

	def isProxy
		false
		
	def add item, type
		if type == TagArgList
			(@last or self).params = item or ListNode.new([])
		else
			@chain.push(@last = TagModifier.new(item))
		return self

	def modifiers
		@modifiers ||= TagModifiers.new(@chain).traverse
		
	def js
		""

	def ref
		"c$.{oid}"

export class TagId < TagPart

	def js
		"id={quoted}"

export class TagFlag < TagPart
	prop condition
	
	def rawClassName
		name.toRaw
		
	def value
		@name
		
	def visit
		@chain.map(|v| v.traverse )
		# @value.traverse if @value
		@condition.traverse if @condition
		@name.traverse if @name:traverse

	def isStatic
		!isConditional and (@name isa Token or @name.isStatic or @name isa MixinIdentifier)

	def isConditional
		!!condition

	def js
		# NOT used anymore
		let val = value.c(as: 'string')
		condition ? "flags.toggle({val},{condition.c})" : "classList.add({val})"
	
export class TagSep < TagPart
	
export class TagArgList < TagPart
	
export class TagAttr < TagPart

	def isSpecial
		String(@name) == 'value'

	def startLoc
		@name?.startLoc

	def endLoc
		@value?.endLoc

	def isStatic
		super and @chain.every(do |item|
			let val = item isa Parens ? item.value : item
			val isa Func ? !val.nonlocals : val.isPrimitive
		)

	def visit
		@chain.map(|v| v.traverse )
		@value.traverse if @value
		@name.traverse if @name:traverse

		let key = @key = String(@name)
		let i = key.indexOf(':')

		if i >= 0
			@ns = key.slice(0,i)
			@key = key.slice(i + 1)

		unless @value
			@autovalue = yes
			@value = STR(key)

		if @chain:length
			@mods = {}
			for m in @chain
				@mods[m.name] = 1

		# if @ns == 'bind'
		#	scope__.imbaDependency('internal/bind')
		self

	def ns
		@ns

	def key
		@key

	def mods
		@mods

	def nameIdentifier
		@nameIdentifier ||= Identifier.new(helpers.dashToCamelCase(key))

	def modsIdentifier
		@modsIdentifier ||= Identifier.new(helpers.dashToCamelCase(key) + '__')

	def js o
		# let mods = AST.compileRaw(@mods or null)
		let val = value.c(o)
		let bval = val
		let op = M('=',option(:op))
		let isAttr = key.match(/^(aria-|data-)/)
		
		if isAttr 
			if STACK.tsc
				return "{@tag.tvar}.setAttribute('{key}',{val})"
			if STACK.platform == 'node'
				return "setAttribute('{key}',{val})"

		if STACK.tsc
			# how do we remove attribute then?
			let path = self.nameIdentifier()
			let access = "{@tag.tvar}.{M(path,@name)}"

			return "{M(access,@name)}{op}{@autovalue ? M('true',@value) : val}"
			
		let key = self.key
		
		if key == 'value' and @tag.@tagName in ['input','textarea','select','option','button'] and STACK.platform != 'node'
			key = 'richValue'

		if ns == 'css'
			"css$('{key}',{val})"
		elif ns == 'bind'
			let path = PATHIFY(value)

			if path isa Variable
				let getter = "function()\{ return {val} \}"
				let setter = "function(v$)\{ {val} = v$ \}"
				bval = "\{get:{getter},set:{setter}\}"
			elif path isa Array
				bval = "[{val[0].c(o)},{val[1].c(o)}]"

			"bind$('{key}',{bval})"
		elif key.indexOf('--') == 0
			let pars = ["'{key}'",val]
			let u = option(:unit)
			let k = StyleTheme.propAbbr(option(:propname))
			if u or k
				pars.push(u ? STR(u) : NULL)
				pars.push(STR(k)) if k

			"css$var({AST.cary(pars).join(',')})"
		elif key.indexOf("aria-") == 0 or (@tag and @tag.isSVG) or key == 'for'
			if ns
				"setns$('{ns}','{key}',{val})"
			else
				"set$('{key}',{val})"
			
		elif key.indexOf("data-") == 0
			"dataset.{key.slice(5)}{op}{val}"
		else
			"{M(helpers.dashToCamelCase(key),@name)}{op}{val}"
	
export class TagAttrValue < TagPart
	
	def isPrimitive
		value.isPrimitive

	def value
		name

	def js
		value.c

	def toRaw
		if value isa Str
			return value.raw
		return null

export class TagHandlerSpecialArg < ValueNode
	def isPrimitive
		yes

	def c
		"'~${value}'"

export class TagModifiers < ListNode
	
	def isStatic
		# the check should be for the params, no?
		@nodes.every(do |item|
			let val = item isa Parens ? item.value : item
			val isa Func ? !val.nonlocals : val.isPrimitive
		)

	def visit
		var keys = {FUNC: 0}
		for node,i in nodes
			let key = String(node.name)
			
			if keys[key]
				node.name = key + '~' + (keys[key]++)
			else
				keys[key] = 1
		self

	def extractDynamics
		return @dynamics if @dynamics
		@dynamics = []

		for part,i in nodes when part isa TagModifier

			for param,k in part.params
				
				if !param.isPrimitive
					let ref = TagDynamicArg.new(param).set(
						key: KEY(part.name),
						index: k
					)
					part.params.swap(param,LIT('null'))
					@dynamics.push(ref)
		return @dynamics

	def c
		if STACK.tsc
			return '[' + nodes.map(do $1.c()).join(',') + ']'
			
		let obj = Obj.new([])
		for part in nodes
			let val = part.params ? Arr.new(part.params) : LIT('true')
			obj.add(KEY(part.name),val)
		return obj.c
		# Arr.new(@nodes).c

	
export class TagModifier < TagPart	
	prop params

	def load value
		if value isa IdentifierExpression
			return value.@single
		return value
	
	def isPrimitive
		!params or params.every do |param| param.isPrimitive
			
	def visit
		if @name isa TagHandlerCallback
			@name.traverse
			@name = @name.value
			
		if @name isa IsolatedFunc # not to be isolated for tsc
			let evparam = @name.params.at(0,yes,'e')
			let stateparam = @name.params.at(1,yes,'$')
			@name.traverse

			@value = @name
			@name = STR('$_')
			@params = ListNode.new([@value].concat(@value.leaks or []))

		# @value.traverse if @value
		# console.log "visit modifier {@name}"
		

		@params.traverse if @params
		
		return self
		# TODO support evaluated paths?
		for param in @params
			if param isa VarOrAccess
				let sym = param.@token.value
				if sym and sym[0] == '$'
					let special = TagHandlerSpecialArg.new(sym.slice(1))
					@params.swap(param,special)
			elif param isa PropertyAccess
				let out = helpers.clearLocationMarkers(param.js())
				if out[0] == '$'
					@params.swap(param,TagHandlerSpecialArg.new(out.slice(1)))

		self
		
	def js
		if STACK.tsc
			return params ? params.c : quoted

		if params and params.count > 0
			"[{quoted},{params.c}]"
		elif params
			"[{quoted}]"
		else
			quoted

export class TagData < TagPart
	
	def value
		name

	def isStatic
		!value or value.isPrimitive
	
	def isSpecial
		true

	def isProxy
		proxyParts isa Array

	def proxyParts
		var val = value

		if val isa ArgList
			val = val.values[0]
			
		if val isa Parens
			val = val.value
		
		if val isa VarOrAccess
			val = val.@variable or val.value
		# console.log "TagData value {val}"

		if val isa Access
			let left = val.left
			let right = val.right isa Index ? val.right.value : val.right
			
			if val isa IvarAccess
				left ||= val.scope__.context
			
			return [left,right]
		return val

	def js
		var val = value

		if val isa ArgList
			val = val.values[0]
			
		if val isa Parens
			val = val.value
		
		if val isa VarOrAccess
			val = val.@variable or val.value
		# console.log "TagData value {val}"

		if val isa Access
			let left = val.left
			let right = val.right isa Index ? val.right.value : val.right
			
			if val isa IvarAccess
				left ||= val.scope__.context
			
			let pars = [left.c,right.c]
				
			if right isa Identifier
				pars[1] = "'" + pars[1] + "'"

			"bind$('data',[{pars.join(',')}])"
		else
			"data=({val.c})"

export class TagDynamicArg < ValueNode
	def c
		value.c

export class TagHandler < TagPart
	
	prop params watch: yes

	def paramsDidSet params
		@chain.push(@last = TagModifier.new('options'))
		@last.params = params

	def visit
		super
		# Replace with something better for debugging
		# if @name and CUSTOM_EVENTS[String(@name)]
		#	scope__.imbaDependency('events/' + String(@name))

	def isStatic
		let valStatic = !value or value.isPrimitive or (value isa Func and !value.nonlocals)
		# check modifiers directly?
		valStatic and @chain.every(do |item|
			let val = item isa Parens ? item.value : item
			val isa Func ? !val.nonlocals : val.isPrimitive
		)
	
	def modsIdentifier
		null
		
	def js o
		if STACK.tsc
			return "[{quoted},{modifiers.c}]"
		return "on$({quoted},{modifiers.c},{scope__.context.c})"

class TagHandlerCallback < ValueNode
	
	def visit
		let val = value
		
		if val isa Parens
			val = val.value
			
		if val isa Func
			val = val.body
			
		# If the value is just a variable we can add it directly?
		
		if val isa Access or val isa VarOrAccess
			# let e = Token.new('IDENTIFIER','e')
			val = CALL(val,[LIT('e')])
		# console.log 'is stack tsc?'
		# TODO don't generate this until visiting the taghandler
		
		# if this is a plain access it should be enough to set a reference
		# to the function once?
			
		value = (STACK.tsc ? Func : IsolatedFunc).new([],[val],null,{})
		
		if value isa IsolatedFunc
			let evparam = value.params.at(0,yes,'e')
			let stateparam = value.params.at(1,yes,'$')

		value.traverse
		return

export class TagBody < ListNode
	
	def add item, o
		if item isa InterpolatedString
			item = item.toArray
			if item:length == 1
				item = TagTextContent.new(item[0])
				
		super(item,o)
		
	def consume node
		if node isa TagLike
			@nodes = @nodes.map do |child|
				if !(child isa Meta) # and !(child isa Assign)
					child.consume(node)
				else
					child
			return self
		super

class TagLike < Node

	def initialize o = {}
		@options = o
		@flags = 0
		@tagvars = {}
		setup(o)
		self

	def sourceId
		@sourceId ||= STACK.sourceId + '-' + oid

	def body
		@body || @options:body

	def value
		@options:value

	def isReactive
		yes
		
	def isDetached
		option(:detached)

	def isSVG
		@isSVG ?= (@parent ? @parent.isSVG : false)

	def parentTag
		let el = @parent
		while el and !(el isa Tag)
			el = el.@parent
		return el

	def setup
		@traversed = no
		@consumed = []
		self

	def root
		@parent ? @parent.root : self

	def register node
		if node isa If or node isa Switch
			flag(F.TAG_HAS_BRANCHES)
			node = TagSwitchFragment.new(body: node)
		elif node isa Loop
			flag(F.TAG_HAS_LOOPS)
			node = TagLoopFragment.new(body: node.body, value: node)
		elif node isa Tag
			flag(F.TAG_HAS_DYNAMIC_CHILDREN) if node.isSlot
		else
			flag(F.TAG_HAS_DYNAMIC_CHILDREN) unless node isa Str
			node = TagContent.new(value: node)

		@consumed.push(node) # why consume if node isa String?
		node.@parent = self
		return node

	def flag key
		@flags |= key

	def type
		"frag"

	def unflag key
		@flags = @flags & ~key

	def hasFlag key
		@flags & key

	def isAbstract
		true

	def isOnlyChild
		isFirstChild && isLastChild

	def isFirstChild
		hasFlag(F.TAG_FIRST_CHILD)

	def isLastChild
		hasFlag(F.TAG_LAST_CHILD)

	def isIndexed
		option(:indexed)

	def isComponent
		@kind == 'component'

	def isSelf
		type isa Self or type isa This
	
	def isShadowRoot
		@tagName and @tagName == 'shadow-root'
		
	def isSlot
		@kind == 'slot'

	def isFragment
		@kind == 'fragment'

	def hasLoops
		hasFlag(F.TAG_HAS_LOOPS)

	def hasBranches
		hasFlag(F.TAG_HAS_BRANCHES)

	def hasDynamicChildren
		hasFlag(F.TAG_HAS_DYNAMIC_CHILDREN)

	def hasDynamicFlags
		hasFlag(F.TAG_HAS_DYNAMIC_FLAGS)

	def hasNonTagChildren
		hasLoops or hasBranches or hasDynamicChildren

	def hasChildren
		@consumed:length > 0

	def tagvar name
		@tagvars[name] ||= scope__.closure.temporary(null,{reuse: yes,alias:"{tagvarprefix}{name}"},"{tagvarprefix}{name}")

	def tagvarprefix
		"{level + 1}"

	def level
		@level

	def parent
		@parent ||= option(:parent)

	def fragment
		@fragment || parent

	def tvar
		@tvar or tagvar('t')

	# built variable
	def bvar
		@bvar or (@parent ? @parent.bvar : tagvar('b'))

	# cache variable
	def cvar
		@cvar or (@parent ? @parent.cvar :  tagvar('c'))

	def vvar do tagvar('v') # value variable
	def kvar do tagvar('k') # key variable

	# for tracking specific changes -- included in end
	# shuold maybe link it with built
	def dvar do tagvar('d') # value variable

	def ref
		@ref || (@cachedRef = "{parent ? parent.cvar : ''}[{osym}]")

	def visit stack
		var o = @options
		var scope = @tagScope = scope__
		let prevTag = @parent = stack.@tag
		@level = (@parent && @parent.@level or 0) + 1
		stack.@tag = null

		for part in @attributes
			part.traverse

		stack.@tag = self
		
		if o:key
			o:key.traverse

		visitBeforeBody(stack)

		if body
			body.traverse

		visitAfterBody(stack)

		stack.@tag = @parent

		unless @parent
			@level = 0
			consumeChildren
			visitAfterConsumed

		self

	def visitBeforeBody
		self

	def visitAfterBody
		self

	def consumeChildren
		return if @consumed:length
		body && body.consume(self)
		let first = @consumed[0]
		let last = @consumed[@consumed:length - 1]

		# too many edgecases to really utilize this
		if !isAbstract
			first.flag(F.TAG_FIRST_CHILD) if first isa TagLike
			last.flag(F.TAG_LAST_CHILD) if last isa TagLike
				
		for item in @consumed when item isa TagLike
			item.@parent = self
			item.@level = (@level + 1)
			item.visitAfterConsumed
			item.consumeChildren

		visitAfterConsumedChildren
		self

	def visitAfterConsumedChildren
		self

	def visitAfterConsumed
		self

	def consume node
		if node isa TagLike
			return node.register(self)

		if node isa Variable
			option('assignToVar',node)
			return self

		if node isa Assign
			return OP(node.op,node.left,self)
		elif node isa VarDeclaration
			return OP('=',node.left,self)
		elif node isa Op
			return OP(node.op,node.left,self)
		elif node isa Return
			# console.log "return is consuming tag"
			option('return',yes)
			return self
		return self

export class TagTextContent < ValueNode

export class TagContent < TagLike
	
	def vvar
		parent.vvar

	def bvar
		parent.bvar # is this not the parent bvar?

	def ref
		fragment.tvar

	def key
		# @key ||= "{parent.cvar}.{oid}"
		@key ||= "{parent.cvar}[{osym}]"

	def isStatic
		value isa Str or value isa Num

	def js
		let value = self.value
		let parts = []
		let isText = (value isa Str or value isa Num or value isa TagTextContent)
		let isStatic = self.isStatic

		if STACK.tsc
			return value.c(o)

		if parent isa TagSwitchFragment or (@tvar and parent isa Tag and (parent.isSlot or isDetached))
			# what if it is a call?
			parts.push("{@tvar}={value.c(o)}")

			if value isa Call or value isa BangCall
				# mark parent to reset imba.ctx at the end
				let k = "{parent.cvar}[{osym('$')}]"
				parts.unshift("imba.ctx=({k} || ({k}=\{_:{fragment.tvar}\}))")
				parts.push("imba.ctx=null")

		elif isOnlyChild and (value isa Str or value isa Num)
			return "{bvar} || {ref}.text$({value.c(o)})"
		elif isStatic
			return "{bvar} || {ref}.insert$({value.c(o)})"
		elif value isa TagTextContent and isOnlyChild and !(parent isa TagSwitchFragment)
			return "({vvar}={value.c(o)},{vvar}==={key} || {ref}.text$(String({key}={vvar})))"

		else
			parts.push("{vvar}={value.c(o)}")

			let inskey = "{parent.cvar}[{osym(:i)}]"

			if value isa Call or value isa BangCall
				# let k = "{parent.cvar}[{osym.c}]"
				let k = "{parent.cvar}[{osym('$')}]"
				# mark parent to reset imba.ctx at the end
				parts.unshift("imba.ctx=({k} || ({k}=\{_:{fragment.tvar}\}))")
				parts.push("imba.ctx=null")

			if value isa TagTextContent
				parts.push("({vvar}==={key}&&{bvar}) || ({inskey} = {ref}.insert$(String({key}={vvar}),{@flags},{inskey}))")
			else
				parts.push("({vvar}==={key}&&{bvar}) || ({inskey} = {ref}.insert$({key}={vvar},{@flags},{inskey}))")

		return "(" + parts.join(',') + ')'

export class TagFragment < TagLike

export class TagSwitchFragment < TagLike
	
	def setup
		super
		@branches = []
		@inserts = []
		
	def getInsertVar index
		@inserts[index] ||= tagvar(self.oid + '$' + index)
		
	def tvar
		fragment.tvar
		
	def register node
		let res = super
		if @branches
			let curr = @branches[@branches:length - 1]
			curr && curr.push(res)
		return res
		
	def visitAfterConsumedChildren

		unless @parent isa TagSwitchFragment
			let max = self.assignChildIndices(0,self)
		return self
	
	def assignChildIndices start,root
		let nr = start
		let max = start
		for branch,i in @branches
			nr = start
			for item in branch
				if item isa TagSwitchFragment
					nr = item.assignChildIndices(nr,root)
				else
					item.@tvar = root.getInsertVar(nr)
					item.set(detached: yes)
					nr++

			if nr > max
				max = nr
		return max

	def js o
		var parts = []

		var top = ''
		if @inserts.len
			top = @inserts.join(' = ') + ' = null'

		var out = body.c(o)
		
		return out if STACK.tsc
		
		parts.push(top)
		parts.push(out)

		for item,i in @inserts
			let key = "{cvar}[{osym(i)}]"
			parts.push("({key} = {tvar}.insert$({item},0,{key}))")
		
		if o:inline
			return parts.join(',')
		else
			return parts.join(';\n')
		

export class TagLoopFragment < TagLike

	def isKeyed
		option(:keyed) or hasFlag(F.TAG_HAS_BRANCHES)

	def consumeChildren
		super

		# determine if the order of elements will ever change inside loop
		if @consumed.every(do $1 isa Tag and !$1.option(:key) and !$1.isDynamicType) and !hasFlag(F.TAG_HAS_BRANCHES)
			set(indexed: yes)
		else
			set(keyed: yes)

	def cvar
		@cvar || tagvar('c')

	def js o

		if stack.isExpression
			let fn = CALL(FN([],[self],stack.scope),[])
			# the inner tag loop has to get the opdated scope as well
			# fn.traverse
			return fn.c

		if STACK.tsc
			return "{tvar} = new DocumentFragment;\n{value.c(o)}"

		# if @tag and @childTags
		let iref = option(:indexed) ? LIT('imba.createIndexedFragment') : LIT('imba.createKeyedFragment')
		# should know how many inner slots this fragment has?
		let cache = parent.cvar
		let parentRef = parent isa TagSwitchFragment ? LIT('null') : fragment.tvar

		let out = ""
		out += "({tvar} = {cache}[{osym}]) || ({cache}[{osym}]={tvar}={iref}({@flags},{parentRef}));\n"
		@ref = "{tvar}"
		out += "{kvar} = 0;\n"
		out += "{cvar}={tvar}.$;\n"
		out += value.c(o)
		out += ";{tvar}.end$({kvar})"
		return out

export class TagIndexedFragment < TagLike

export class TagKeyedFragment < TagLike

export class TagSlotProxy < TagLike

	def ref
		tvar

	def tagvarprefix
		oid+'S'


export class Tag < TagLike
	prop attrmap

	def setup
		super
		@attributes = @options:attributes or []
		@attrmap = {}
		@classNames = []
		@className = null

	def isAbstract
		isSlot or isFragment

	def attrs
		@attributes

	def traverse 
		return self if @traversed
		@tid = STACK.generateId('tag')
		scope__.imbaDependency('index')
		@tagDeclaration = STACK.up(TagDeclaration)
		let close = @options:close
		let body = @options:body or []
		let returns = self

		if close and close.@value == '/>' and body.len
			returns = [self].concat(body.@nodes)
			@options:body = ArgList.new([])

		super

		return returns

	def visitBeforeBody stack
		let type = @options:type
		type && type.traverse

		if isSelf or (tagName.indexOf('-') >= 0) or isDynamicType or (type && type.isComponent)
			@options:custom = yes
			@kind = 'component'
		else
			@kind = 'element'

		if type isa TagTypeIdentifier
			if type.isAsset
				@assetName = type.toAssetName
				@asset = scope__.root.lookupAsset(@assetName)
				@isAsset = yes
				@isSVG = yes

		if attrs:length == 0 && !@options:type
			@options:type = 'fragment'
			
		let tagName = self.tagName

		if tagName == 'slot'
			@kind = 'slot'

		elif tagName == 'fragment'
			@kind = 'fragment'
			
		if tagName == 'shadow-root'
			@kind = 'shadow-root'
			
		if isSelf
			let decl = stack.up(TagDeclaration)
			decl.set(self: self,sourceId: sourceId) if decl
			
		@tagName = tagName

		@dynamics = []
		
		let i = 0
		while i < @attributes:length
			let item = @attributes[i++]
			if item isa TagFlag and item.name isa StyleRuleSet				
				if item.name.placeholders:length
					for ph in item.name.placeholders
						let setter = TagAttr.new(ph.name)
						setter.@tag = self
						setter.value = ph.value
						setter.set(
							propname: ph.@propname
							unit: ph.option('unit')
						)
						@attributes.splice(i++,0,setter)
						setter.traverse
						

		@attributes = @attributes.filter do |item|

			if item isa TagFlag and item.isStatic
				@classNames.push(item)
				return false

			if item == @attrmap:$key
				self.set(key: item.value)
				return false

			if !item.isStatic
				@dynamics.push(item)

			return true

		# if @classNames:length
		#	@className = "'{@classNames.join(' ')}'"

		if isSlot
			# @tvar = tagvar('t'+oid)
			let name = @attrmap:name ? @attrmap:name.value : '__'
			name = name.raw if name isa Str
			set(name: name)
			@attributes = []
		
		if @options:reference
			let tagdef = stack.up(TagDeclaration)
			if tagdef
				tagdef.addElementReference(@options:reference,self)
		super

	def register node
		node = super(node)

		if node isa TagLike and (isComponent and !isSelf)
			let slotKey = node isa Tag ? node.@attrmap:slot : null
			let name = '__'
			if slotKey
				if slotKey.value isa Str
					name = slotKey.value.raw
			# let name = slotKey ? slotKey.value .toRaw : '__'
			let slot = getSlot(name)
			node.@fragment = slot
		return node

	def visitAfterBody stack
		self

	def visitAfterConsumed
		if isSVG
			@kind = 'svg'		
		
		if @parent isa TagLoopFragment and isDynamicType
			if option(:key)
				set(key: OP('+',option(:key),OP('+',STR(' '),vvar)) )
		self

	def visitAfterConsumedChildren
		if isSlot and @consumed:length > 1
			set(markWhenBuilt: yes, reactive: yes)
		return

	def getSlot name
		@slots ||= {}
		@slots[name] ||= TagSlotProxy.new(parent: self, name: name)

	def addPart part, type, tok
		let attrs = @attributes
		let curr = attrs.CURRENT
		let next = curr

		if type == TagId
			set(id: part)

		if type == TagArgList
			if attrs:length == 0
				set(args: part)
				return self

		if type == TagSep
			next = null

		elif type == TagAttrValue
			if part isa Parens
				part = part.value

			if curr isa TagFlag
				curr.condition = part
				flag(F.TAG_HAS_DYNAMIC_FLAGS)
				curr.set(op: tok)
			elif curr isa TagHandler
				
				if part
					# if part isa Access or part isa VarOrAccess
					#	# let e = Token.new('IDENTIFIER','e')
					#	part = CALL(part,[LIT('e')])
					# console.log 'is stack tsc?'
					# TODO don't generate this until visiting the taghandler
					# part = (STACK.tsc ? Func : IsolatedFunc).new([],[part],null,{})
					curr.add(TagHandlerCallback.new(part),type)
				
			elif curr
				curr.value = part
				curr.set(op: tok)
				
		elif curr isa TagHandler
			if part isa IdentifierExpression and part.single and !part.isPrimitive
				# console.log 'is stack tsc?'
				part = (STACK.tsc ? Func : IsolatedFunc).new([],[part.single],null,{})
				
			curr.add(part,type)
		elif curr isa TagAttr
			curr.add(part,type)

		elif type == TagData
			let bind = String(self.type) in ['input','textarea','select','button','option']
			bind = true
			curr = TagAttr.new(bind ? 'bind:data' : 'data',self)
			curr.value = part.first
			attrs.push(curr)
			next = null
			
		else

			if type == TagFlag and part isa IdentifierExpression and !part.isPrimitive
				flag(F.TAG_HAS_DYNAMIC_FLAGS)

			if part isa type
				part.@tag = self
			else
				part = type.new(part,self)

			attrs.push(next = part)

			if next isa TagAttr and next.name.isPrimitive
				let name = String(next.name.toRaw)
				if name == 'bind'
					(next.@name.@single or next.@name).@value = 'bind:data'
					name = 'bind:data'
				@attrmap[name] = next

		if next != curr
			attrs.CURRENT = next
		self

	def type
		@options:type || (@attributes:length == 0 ? :fragment : :div)

	def tagName
		@tagName || String(@options:type)

	def isDynamicType
		type isa ExpressionNode

	def isSVG
		@isSVG ?= ((type isa TagTypeIdentifier and type.isSVG) or (@parent and @parent.isSVG))
	
	def isAsset
		@isAsset or no
		# type isa TagTypeIdentifier and type.isAsset
	
	def create_
		if isFragment or isSlot
			LIT('imba.createLiveFragment')
		elif isAsset
			LIT('imba.createAssetElement')
		elif isSVG
			LIT('imba.createSVGElement')
		elif isComponent
			LIT('imba.createComponent')
		else
			LIT('imba.createElement')

	def isReactive
		option(:reactive) or (@parent ? @parent.isReactive : !(scope__ isa RootScope))

	def isDetached
		option(:detached)

	def js o
		var stack = STACK
		var isExpression = STACK.isExpression

		var head = []
		var out = []
		var foot = []

		var add = do |val|
			if val isa Variable
				val = val.toString
			out.push(val)
		
		
		var parent = self.parent
		var fragment = self.fragment
		var component = @tagDeclaration
		let oscope = @tagDeclaration ? @tagDeclaration.scope : null

		let typ = isSelf ? "self" : (isFragment ? "'fragment'" : (type:isClass and type.isClass ? type.toTypeArgument : "'" + type.@value + "'"))

		var wasInline = o:inline
		var isSVG = self.isSVG
		var isReactive = self.isReactive

		var canInline = no
		var shouldEnd = isComponent or @attrmap:route or @attrmap:routeTo or @attrmap['route-to']

		var dynamicKey = null
		var ownCache = no

		if @asset
			typ = "'{@assetName}'"

		var slotPath = isSlot ? OP('.',LIT("{fragment.root.tvar}.__slots"),STR(option(:name))).c : ""

		if stack.tsc
			# if tag is expression we want to suppress certain warnings
			if type isa TagTypeIdentifier and !isSelf
				add "{tvar} = new {M(type.toClassName,type)}"
			elif isSelf
				add "{tvar} = {type.c}"
			else
				add "{tvar} = new {M('HTMLElement',type)}"
				add "{type.c}" # this is the string

			for item in @attributes
				if item isa TagAttr or item isa TagHandler
					add item.c(o) # M("{tvar}.{item.c(o)}",item)
					# add M("{tvar}.{item.c(o)}",item)
				self
			for item in body
				add item.c

			return out.join(";\n")

		# whether this tag should set a variable indicating
		# whether this was built now or not
		# basically whether we need a reference at all?
		var markWhenBuilt = shouldEnd or hasDynamicFlags or attrs:length or option(:markWhenBuilt) or isDetached
		# when it has any attributes? - but not text or

		var inCondition = parent && parent.option(:condition)

		if type isa ExpressionNode
			add "{vvar}={type.c}"
			unless (option(:key) or parent isa TagLoopFragment)
				add "{kvar}='{oid}_'+{vvar}"

			typ = vvar
			dynamicKey = kvar

		if stack.option(:hasScopedStyles)
			@classNames.unshift(stack.sourceId)

		if component and !isSelf
			if let cname = component.cssref(scope__)
				@classNames.push cname
		
		if option(:reference)
			if oscope
				let name = String(option(:reference)).slice(1)
				@classNames.push(name)
				if component
					@classNames.push("ref--{name}")
		
		if option(:key)
			set(detached: yes)
		
		if @classNames:length
			let names = []
			let dynamic = no
			for cls,i in @classNames
				if cls isa TagFlag
					if cls.name isa MixinIdentifier
						names.push(cls.name.c(as:'substr'))
						dynamic = yes
					else
						names.push(cls.rawClassName)
				elif cls isa Node
					dynamic = yes
					names.push('${' + cls.c + '}')
				else
					names.push(cls)

			let q = dynamic ? '`' : "'"
			@className = q + names.join(' ') + q

		var params = [
			typ,
			(fragment and !option(:detached) ? fragment.tvar : 'null'),
			@className or 'null',
			'null'
		]

		var nodes = body ? body.values : []

		if nodes:length == 1 and nodes[0] isa TagContent and nodes[0].isStatic and !isSelf and !isSlot
			params[3] = nodes[0].value.c
			nodes = []

		# checking to see if a node is static enough to be inserted directly into the dom without
		# any references.
		if @dynamics:length == 0 and !hasDynamicFlags and !dynamicKey
			if nodes.every(|v| v isa Str or (v isa Tag and !v.isDynamicType))
				if !shouldEnd and !hasNonTagChildren and (parent isa Tag) and !isSlot and !option(:dynamic)
					canInline = yes

		if isFragment or isSlot
			params = [@flags].concat(params.slice(1,2)) # .slice(1,3)

		if isSlot
			# the slot is not supposed to be inserted immediately
			params[1] = 'null'
		
		var ctor = M("{create_}({params.join(',')})",type)
		
		if option(:reference)
			# what if it is on root?
			# should also check if there is already an element like this
			# ctor = CALL(OP('.',LIT(ctor),'ref$'),[STR(option(:reference))])
			ctor = OP('=',OP('.',scope__.context,option(:reference)),LIT(ctor)).c()
			
		ctor = "{tvar}={ctor}"

		if option(:assign)
			# push it into ctor if it is not a variable assignment
			# otherwise we always want to assign it
			ctor = OP('=',option(:assign),LIT(ctor)).c()

		if !parent
			@ref = "{tvar}"
			@cvar = tvar
			
			if isSelf
				add "{tvar}=this"
				add "{tvar}.open$()"
				add "({bvar}={dvar}=1,{tvar}[{osym}] === 1) || ({bvar}={dvar}=0,{tvar}[{osym}]=1)"

			elif isReactive
				let scop = scope__.closure
				# add "{bvar}={dvar}=1"
				let k = "{scop.tagCache}[{osym}]"
				add "({bvar}={dvar}=1,{tvar}={k}) || ({bvar}={dvar}=0,{k}={ctor})"
				add "{bvar} || ({tvar}[{gsym('##up')}]={scop.tagCache}._)" # really? 
				@ref = tvar
				o:inline = yes if isExpression
				# if @consumed:length or @dynamics:length
				# 	@cvar ||= tvar
				# 	# add "{cvar} = {tvar}.${oid} || ({tvar}.${oid}=\{\})"
			else
				add "({ctor})"
				option(:inline,canInline = yes)
				o:inline = yes

		else
			if isShadowRoot
				let key = "{cvar}[{osym}]"
				add "{tvar}={key} || ({key}={fragment.tvar}.attachShadow(\{mode:'open'\}))"
					
			elif isSlot and !hasChildren
				let key = "{cvar}[{osym}]"
				add("{tvar}={slotPath}")
				add("({key} = {fragment.tvar}.insert$({tvar},{@flags},{key}))")

			elif isSlot and @consumed:length == 1
				# single child can act as slot?
				# if it is a string we dont really want to insert it at all
				@consumed[0].set(dynamic: yes, detached: yes)
				@consumed[0].@tvar = tvar
				@consumed[0].@parent = parent
				# add("{tvar}")
			# this is a functional tag component
			elif option(:args)
				let key = "{cvar}[{osym}]"
				let ckey = "{cvar}[{osym('$')}]"
				let inskey = "{cvar}[{osym('ins')}]"
				add("imba.ctx=({ckey} || ({ckey}=\{\}))")
				
				let call = CALL(option(:type).toFunctionalType,option(:args))
				add("{tvar}={call.c(o)}")
				add("imba.ctx=null")
				add("{tvar}==={ref} || ({inskey} = {fragment.tvar}.insert$({ref}={tvar},{@flags},{inskey}))")
				# call the tag - type?

			elif parent isa TagLoopFragment
				# what if we are not reactive at all?
				if parent.isKeyed and !option(:key)
					# FIXME now we need a separate cache?!
					option(:key,OP('+',LIT("'{oid}$'"),parent.kvar))
					if isDynamicType
						set(key: OP('+',option(:key),vvar))
					# @ref = "{parent.cvar}[{parent.kvar}]"

				if option(:key)
					add "{kvar}={option(:key).c}"
					@ref = "{parent.cvar}[{kvar}]"
				elif parent.isIndexed
					@ref = "{parent.cvar}[{parent.kvar}]"

				# if we add our own bvar?
				@bvar = tagvar(:b)
				add "({bvar}={dvar}=1,{tvar}={ref}) || ({bvar}={dvar}=0,{ref}={ctor})"
				@ref = "{tvar}"

				if isDetached or true
					add "{bvar}||({tvar}[{gsym('##up')}]={fragment.tvar})"

				# dont add cvar always!
				# rule is just "do we need our own cache?"
				if @dynamics:length or (@consumed:length and nodes:length)
					ownCache = yes
					# console.log "has dynamics? {@dynamics:length}",@consumed.map(|v| v:constructor:name)
					# @cvar = tagvar(:c)
					# add "{cvar}={ref}.${oid} || ({ref}.${oid}=\{\})"

			elif !isReactive
				add "({ctor})"

			elif canInline
				@ref = tvar
				@bvar = parent.bvar
				add "{parent.bvar} || ({ctor})"
			else
				let cref = @cref = "{cvar}[{osym}]"
				let ref = dynamicKey ? "{cvar}[{dynamicKey}]" : cref
				
				if option(:key)
					let dref = @dref = "{cvar}.${oid}"
					add "{dref} || ({dref}=\{\})"
					dynamicKey = option(:key).c
					ref = "{dref}[{dynamicKey}]"

				if markWhenBuilt
					@bvar = tagvar(:b)
					add "({bvar}={dvar}=1,{tvar}={ref}) || ({bvar}={dvar}=0,{ref}={ctor})"
				else
					add "({tvar} = {ref}) || ({ref}={ctor})"

				if isDetached
					add "{bvar}||({tvar}[{gsym('##up')}]={fragment.tvar})"

				@ref = tvar

				if dynamicKey
					ownCache = yes
					
				if parent isa TagSwitchFragment
					# console.log 'is tag switch!!!'
					ownCache = yes

			if ownCache
				@cvar = tvar # tagvar(:c)
				# console.log 'FIX ownCache'
				# add "{cvar}={ref}.${oid} || ({ref}.${oid}=\{\})"

					

		if @slots
			for own name, slot of @slots
				# TODO Make sure slot is not already used
				add "{slot.tvar} = {tvar}.slot$('{name}',{cvar})"

		let flagsToConcat = []

		for item in @attributes
			if item.@chain and item.@chain:length and !(item isa TagHandler)
				let mods = item.modifiers
				let dyn = !mods.isStatic

				let specials = mods.extractDynamics()
				let modid = item.modsIdentifier
				let modpath = modid ? OP('.',tvar,modid).c : "{cvar}[{mods.osym}]"

				if dyn
					add "{vvar} = {modpath} || ({mods.c(o)})"
					for special in specials
						let k = special.option(:key)
						let i = special.option(:index)
						add "{OP('.',vvar,k).c}[{i}]={special.c(o)}"
					add "{bvar} || ({modpath}={vvar})"
				else
					add "{bvar} || ({modpath}={mods.c(o)})"
			
			if !isReactive
				# buggy
				add "{tvar}.{item.c(o)}"
			elif item.isStatic
				add "{bvar} || ({tvar}.{item.c(o)})"
			else
				let iref = "{cvar}[{item.osym}]"

				if item isa TagFlag
					let cond = item.condition
					let val = item.name
					let cref
					let vref
			
					if cond and !cond.isPrimitive
						cref = "{cvar}[{cond.osym}]"
						add "({vvar}=({cond.c(o)}||undefined),{vvar}==={cref}||({dvar}|={F.DIFF_FLAGS},{cref}={vvar}))"

					if val and !(val isa Token) and !val.isPrimitive and !(val isa MixinIdentifier) and !(val isa StyleRuleSet)
						vref = "{cvar}[{val.osym}]"
						add "({vvar}={val.c(o)},{vvar}==={vref}||({dvar}|={F.DIFF_FLAGS},{vref}={vvar}))"

					if cref and vref
						flagsToConcat.push("({cref} ? ({vref}||'') : '')")
					elif cref
						flagsToConcat.push("({cref} ? {val.c(as:'string')} : '')")
					elif vref
						flagsToConcat.push("({vref}||'')")
					elif val isa MixinIdentifier
						flagsToConcat.push(val.c(as:'string'))
					else
						flagsToConcat.push("'{val.c(as:'substring')}'")

				elif item isa TagHandler
					let mods = item.modifiers
					let specials = mods.extractDynamics()
	
					add "{vvar} = {iref} || ({iref}={mods.c(o)})"
					for special in specials
						let k = special.option(:key)
						let i = special.option(:index)
						add "{OP('.',vvar,k).c}[{i}]={special.c(o)}"

					mods = vvar
					add "{bvar} || {ref}.on$({item.quoted},{mods.c},{scope__.context.c})"

				elif item isa TagAttr and item.ns == 'bind'
					
					let rawVal = item.value
					let val = PATHIFY(rawVal)

					shouldEnd = yes
					if val isa Array
						let target = val[0]
						let key = val[1]
						let bval = "[]"
						if target isa Literal and key isa Literal
							bval = "[{target.c(o)},{key.c(o)}]"
						elif key isa Literal
							bval = "[null,{key.c(o)}]"

						add "{vvar}={iref} || ({iref}={ref}.bind$('{item.key}',{bval}))"
						for part,i in val
							unless part isa Literal
								add "{vvar}[{i}]={part.c(o)}"
						# add "({vvar}={rawVal.c(o)},{vvar}=={ref}.value || ({iref}={ref}.bind$('{item.key}',{mods},{bval}))"
					elif val isa Variable
						let getter = "function()\{ return {val.c(o)} \}"
						let setter = "function(v$)\{ {val.c(o)} = v$ \}"
						let bval = "\{get:{getter},set:{setter}\}"
						add "{bvar} || {ref}.bind$('{item.key}',{bval})"
				else
					item.option(svg: true) if isSVG
					let val = item.value
					if item.valueIsStatic
						add "{bvar} || ({ref}.{M(item.js(o),item)})"
					elif val isa Func
						add "({ref}.{item.js(o)})"
					elif val.@variable
						let vc = val.c(o)
						item.value = LIT("{iref}={vc}")
						add "({vc}==={iref} || ({ref}.{M item.js(o),item}))"
					else
						item.value = LIT("{iref}={vvar}")
						add "({vvar}={val.c(o)},{vvar}==={iref} || ({ref}.{M item.js(o),item}))"

		if flagsToConcat:length or (isSelf && @className)
			flagsToConcat.unshift(@className) if @className
			let meth = isSelf ? 'flagSelf$' : 'flag$'
			let cond = "{dvar}&{F.DIFF_FLAGS}"
			cond = "(!{bvar}||{cond})" if isSelf
			add "({cond} && {tvar}.{meth}({flagsToConcat.join("+' '+")}))"

		# When there is only one value and that value is a static string or num - include it in ctor
		# loop through attributes etc
		# add 

		let count = nodes:length

		for item in nodes
			if item isa Str # static for sure
				# should this not go into a TagLike? Definitely
				if isReactive
					add "{bvar} || {tvar}.insert$({item.c(o)})"
				else
					add "{tvar}.insert$({item.c(o)})"
			else
				add item.c(o)


		if shouldEnd
			foot.push("{bvar} || !{tvar}.setup || {tvar}.setup({dvar})") unless isSelf
			foot.push(isSelf ? "{tvar}.close$({dvar})" : "{tvar}.end$({dvar})")

		if parent isa TagLoopFragment
			
			if parent.isKeyed
				foot.push "{parent.ref}.push({tvar},{parent.kvar}++,{kvar})"
			elif parent.isIndexed
				foot.push "{parent.kvar}++"

		elif isFragment and parent and !(parent isa TagSwitchFragment)
			# not fragment.tvar?
			foot.push "{fragment.ref}.insert$({tvar},{@flags})"

		elif parent and !(parent isa TagSwitchFragment) and (isComponent or dynamicKey)
			let pref = fragment.ref
			let cref = @cref
			if dynamicKey
				foot.push "({tvar}=={cref}) || (!{cref} && ({cref}={tvar}).insertInto$({pref})) || {cref}.replaceWith$({cref}={tvar})"
			elif !isDetached
				foot.push "{bvar} || {tvar}.insertInto$({pref})"

		if option(:fragmented)
			add "imba.ctx=null"

		if !parent
			if option(:return)
				foot.push "return {tvar}"
			elif !isReactive or o:inline
				foot.push "{tvar}"

		out = out.concat(foot)

		if o:inline
			o:inline = wasInline
			let js = '(' + out.join(',\n') + ')'
			if isSlot and hasChildren
				let key = "{cvar}[{osym}]"
				let key_ = "{cvar}[{osym '_'}]"
				let key__ = "{cvar}[{osym '__'}]"
				let post = "{tvar}==={key__} || ({key_} = {fragment.tvar}.insert$({key__}={tvar},{@flags},{key_}))"
				js = "({tvar}={slotPath}),(!{tvar} || {tvar}.isEmpty$() && {js}),({post})"
			return js
		else
			o:inline = wasInline
			let js = out.join(";\n")
			if isSlot and hasChildren
				# let key = "{cvar}.{oid}"
				let key = "{cvar}[{osym}]"
				let key_ = "{cvar}[{osym '_'}]"
				let key__ = "{cvar}[{osym '__'}]"
				let post = "{tvar}==={key__} || ({key_} = {fragment.tvar}.insert$({key__}={tvar},{@flags},{key_}))"
				js = "{tvar}={slotPath};\nif(!{tvar} || {tvar}.isEmpty$())\{\n{js}\n\}\n{post}"
			return js


export class TagWrapper < ValueNode

	def visit
		if value isa Array
			value.map(|v| v.traverse)
		else
			value.traverse
		self

	def c
		"{scope__.imba.c}.getTagForDom({value.c(expression: yes)})"


# SELECTORS


export class Selector < ListNode

	def initialize list, options
		@nodes = list or []
		@options = options

	def add part, typ
		push(part)
		self

	def isExpressable
		yes

	def visit
		for item in @nodes
			item.traverse unless item isa Token

	def query
		var str = ""
		var ary = []

		for item in nodes
			var val = item.c
			if item isa Token
				ary.push("'" + val.replace(/\'/g,'"') + "'")
			else
				ary.push(val)

		return ary.join(' + ')
		
	def toString
		AST.cary(nodes).join('')


	def js o
		var typ = option(:type)
		var q = AST.c(query)
		var imba = scope__.imba.c

		if typ == '%'
			"{imba}.q$({q},{o.scope.context.c(explicit: yes)})" # explicit context
		elif typ == '%%'
			"{imba}.q$$({q},{o.scope.context.c(explicit: yes)})"
		else
			"{imba}.q{typ}({q})"

export class SelectorPart < ValueNode

# DEFER

export class Await < ValueNode

	prop func

	def js o
		return "await {value.c}" if option(:native)
		# introduce a util here, no?
		CALL(OP('.',Util.Promisify.new([value]),'then'),[func]).c

	def visit o
		# things are now traversed in a somewhat chaotic order. Need to tighten
		# Create await function - push this value up to block, take the outer
		value.traverse

		var fnscope = o.up(Func) # do |item| item isa MethodDeclaration or item isa Fun

		if fnscope
			set(native: yes)
			fnscope.set(async: yes)
			return self

		###
		Top-level await is supported from node 14.8.0 but only when
		using loading script as es module, which breaks require etc.
		Right now we use our old async func transformations for top-level awaits
		but that feels hacky.
		###
		warn "toplevel await not allowed"

		var block = o.up(Block) # or up to the closest FUNCTION?
		var outer = o.relative(block,1)
		var par = o.relative(self,-1)

		func = AsyncFunc.new([],[])
		# now we move this node up to the block
		func.body.nodes = block.defers(outer,self)
		func.scope.visit

		# if the outer is a var-assignment, we can simply set the params
		if par isa Assign
			par.left.traverse
			var lft = par.left.node
			# Can be a tuple as well, no?
			if lft isa VarReference
				# the param is already registered?
				# should not force the name already??
				# beware of bugs
				func.params.at(0,yes,lft.variable.name)
			else
				par.right = func.params.at(0,yes)
				func.body.unshift(par)
				func.scope.context

		# If it is an advance tuple or something, it should be possible to
		# feed in the paramlist, and let the tuple handle it as if it was any
		# other value

		# CASE If this is a tuple / multiset with more than one async value
		# we need to think differently.

		# now we need to visit the function as well
		func.traverse
		# pull the outer in
		self

export class AsyncFunc < Func

	def initialize params, body, name, target, options
		super(params,body,name,target,options)

	def scopetype do LambdaScope


# IMPORTS
export class ESMSpecifier < Node
	prop alias
	prop name

	def initialize name, alias
		@name = name
		@alias = alias

	def visit stack
		@declaration = stack.up(ESMDeclaration)
		if @declaration isa ImportDeclaration
			@importer = @declaration
		else
			@exporter = @declaration
		@cname = helpers.clearLocationMarkers(@name.c())
		@key = @alias ? helpers.clearLocationMarkers(@alias.c()) : @cname
		
		# only register variable for imports?
		
		if @exporter
			# lookup variable
			unless @exporter.source
				@variable = scope__.root.lookup(@cname)
		else
			@variable = scope__.root.register(@key, self, type: 'imported')
			stack.registerSemanticToken (@alias or @name), @variable
		self


	def js
		if @alias
			"{@name.c()} as {@alias.c()}"
		else
			"{@name.c()}"


export class ImportSpecifier < ESMSpecifier

	def visit
		super
		if @importer and STACK.cjs
			# FIXME will bug out if trying to set the variable
			@variable.@c = OP('.',@importer.variable,@name).c

export class ImportNamespaceSpecifier < ESMSpecifier

	def visit
		super
		if @importer and STACK.cjs
			# FIXME will bug out if trying to set the variable
			@variable.@c = @importer.variable.c
		
		
export class ExportSpecifier < ESMSpecifier

export class ExportAllSpecifier < ESMSpecifier

export class ImportDefaultSpecifier < ESMSpecifier

	def visit
		super
		if STACK.cjs
			if @importer
				@variable.@c = "{@importer.variable.c}.default"

export class ESMSpecifierList < ListNode
	
	def js
		'{' + super + '}'


export class ESMDeclaration < Statement
	prop variable
	prop source
	
	def initialize keyword, specifiers, source
		setup
		@keyword = keyword
		@specifiers = specifiers
		@source = source
		@defaults = (specifiers and specifiers.find(do $1 isa ImportDefaultSpecifier))

	def isExport
		String(keyword) == 'export'

	def js
		let kw = M(keyword.c,keyword)
		if @specifiers and @source
			"{kw} {AST.cary(@specifiers).join(',')} from {@source.c}"
		elif @specifiers
			"{kw} {AST.cary(@specifiers).join(',')}"
		elif @source
			"{kw} {@source.c}"

export class ImportDeclaration < ESMDeclaration

	def js
		if STACK.cjs
			var src = @source.c
			# we need to combine the requires
			let reqjs = "require({src})"
			unless @specifiers
				return reqjs
			
			# let wildcards = 
			if @defaults and @specifiers:length == 1
				return "var {@variable.c} = {util.requireDefault(LIT(reqjs)).c}"
			else
				return "var {@variable.c} = {reqjs}"

		if @specifiers and @source
			"{M(keyword.c,keyword)} {AST.cary(@specifiers).join(',')} from {@source.c}"
		else
			"{M(keyword.c,keyword)} {@source.c}"

	def visit
		if STACK.cjs and @specifiers
			var src = @source.c
			var m = helpers.clearLocationMarkers(src).match(/([\w\_\-]+)(\.js|imba)?[\"\']$/)
			@alias = m ? '_$' + m[1].replace(/[\/\-]/g,'_') : 'mod$'
			@variable = scope__.register(@alias,null,system: yes)
		
		for item in @specifiers
			item?.traverse()
			
		return

export class ExportDeclaration < ESMDeclaration

	def visit
		scope__.root.activateExports()

		for item in @specifiers
			item?.traverse()
		self
		
	def js
		let kw = M(keyword.c,keyword)
		let cjs = STACK.cjs
		
		if cjs
			let out = []
			
			if @source
				@variable ||= scope__.register(null,null,system: yes)
				let decl = "var {@variable.c} = require({@source.c})"
				out.push(decl)
				
				let tpl = '''
				Object.defineProperty(exports, $name$, {
					enumerable: true, get: function get() { return $path$; }
				});
				'''
				
				for item in @specifiers[0]
					let js = tpl.replace('$name$',(item.alias or item.name).toStr().c())
					js = js.replace('$path$',OP('.',@variable,item.name).c())
					out.push(js)

			else
				for item in @specifiers[0]
					let op = OP('=',OP('.',LIT('exports'),item.alias or item.name),item.@variable)
					out.push(op.c)

			return out.join(';\n')

		if @specifiers and @source
			"{kw} {AST.cary(@specifiers).join(',')} from {@source.c}"
		elif @specifiers
			"{kw} {AST.cary(@specifiers).join(',')}"
		elif @source
			"{kw} {@source.c}"
		

export class ExportAllDeclaration < ExportDeclaration
export class ExportNamedDeclaration < ExportDeclaration

export class Export < ValueNode
		
	def loc
		let kw = option(:keyword)
		kw and kw:region ? kw.region : super

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super
		
	def visit
		scope__.root.activateExports()

		value.set(
			export: (option(:keyword) or self),
			return: option(:return),
			default: option(:default)
		)
		super

	def js o
		# p "Export {value}"
		# value.set export: self, return: option(:return), default: option(:default)

		# if value isa VarOrAccess
		# 	return "exports.{value.c} = {value.c};"
		let isDefault = option(:default)

		if value isa ListNode
			value.map do |item| item.set export: self

		if value isa MethodDeclaration or value isa ClassDeclaration
			return value.c

		if isDefault
			if !STACK.cjs
				return "export default {value.c}"
			else
				return "exports.default = {value.c}"

		return value.c

export class Require < ValueNode

	def js o
		var out = value isa Parens ? value.value.c : value.c
		out == 'require' ? 'require' : "require({out})"

export class EnvFlag < ValueNode
	
	def initialize
		super
		@key = String(@value).slice(1,-1)		

	def raw
		@raw ?= STACK.env("" + @key)

	def isTruthy
		var val = raw
		return !!val if val !== undefined
		return undefined

	def loc
		[0,0]

	def c
		var val = raw
		var out = val
		if val !== undefined
			if val isa String
				if val.match(/^\d+(\.\d+)?$/)
					out = String(parseFloat(val))
				else
					out = "'{val}'"
			else
				out = "{val}"

		else
			out = "ENV_{@key}"
		
		return M(out,@value)


export class StyleNode < Node

export class StyleSelector < StyleNode

# all weird parts of a selector? Or do we just compile it?

export class StyleRuleSet < StyleNode
	
	# selector
	def initialize selectors, body
		@placeholders = []
		@selectors = selectors
		@body = body
		
	def isStatic
		true
	
	def isGlobal
		!!option(:global)
	
	def addPlaceholder item
		@placeholders.push(item)
		return self
		
	def placeholders
		@placeholders
		
	def visit stack, o
		let cmp = @tagDeclaration = stack.up(TagDeclaration)
		@flag = stack.up(TagFlag)
		@tag = @flag and @flag.@tag
		
		let sel = String(@selectors).trim

		if sel.match(/^\%[\w\-]+$/)
			set(mixin: sel.slice(1))
			@identifier = MixinIdentifier.new(sel)
			@name = sel.slice(1) + '-' + sourceId + oid
			@sel = sel # "%{@name}"
			@variable = scope__.register(@identifier.symbol,self,type: 'const', lookup: true)
			# @variable.@resolvedValue = @sel
		
		if stack.parent isa ClassBody
			# console.log 'ruleset is inside of class!!'
			let owner = stack.up(2)
			if owner isa TagDeclaration
				if !@variable
					@sel = String(@selectors).trim or '&'
					if @sel.match(/^\>{1,3}/)
						@sel = "& {@sel}"
					elif @sel.match(/^\@/) and !@sel.match(/&/)
						@sel = "&{@sel}"

					# @sel = @sel.replace('&',".{cmp.cssns}_")
					# @sel = "& {@sel}" if @sel.indexOf('&') == -1
					@sel = @sel.replace('&',".{cmp.cssns}_")
				set(inClassBody: yes)
				@rulescope = owner.scope__
				
				if cmp
					cmp.set(hasScopedStyles: yes)
				
			else
				yes # THROW here

			# FIX the selector based on the tag
		elif option(:toplevel)
			@sel ||= String(@selectors).trim

		elif o:rule
			@sel ||= @selectors?.toString.trim
			@sel = "& {@sel}" if @sel.indexOf('&') == -1

		elif !@name
			# if this is unconditional - we should only need to use the unique
			# class name of the element
			@name = (cmp ? cmp.cssns : sourceId) + oid
			@sel = ".{@name}"
		
		@selectors?.traverse
		
		@styles = {}
		@body?.traverse(rule: self, styles: @styles, rootRule: (o:rule or self))

		if o:rule and o:styles
			if o:styles[@sel] # 'Â§ '+
				Object.assign(o:styles[@sel],@styles)
			else
				o:styles[@sel] = @styles

		else
			let pri = !!@flag ? (@tag and @tag.isSelf ? 2 : 2) : 0
			pri = 1 if pri < 1 and option(:inClassBody)
			# might want to send in the rule itself instead?
			let component = @tagDeclaration
			let opts = {
				selectors:[]
				component: cmp
				ns: cmp ? cmp.cssns : sourceId
				priority: pri
				forceLocal: !@flag && (cmp or !isGlobal)
				inline: !!@flag
				global: !!isGlobal
				mixins: {}
			}

			opts:resolver = do |name|
				let varname = 'mixin$' + name
				if let resolved = scope__.lookup('mixin$' + name)
					if resolved.@declarator isa StyleRuleSet
						return resolved.@declarator.@sel
					else
						return resolved
				return null

			@css = StyleRule.new(null,@sel,@styles,opts).toString

			if opts:hasScopedStyles
				(cmp or stack).set(hasScopedStyles: yes)

			@css = @css.replace(/\.mixin___([\w\-]+)/g) do |m,name|
				let varname = 'mixin$' + name
				if let resolved = scope__.lookup(varname)
					if resolved.@declarator isa StyleRuleSet
						return '.'+resolved.@declarator.@name
					else
						return m

			scope__.root.styles.push({
				type: 'css'
				processed: @css
			})
			
		self
		
	def toRaw
		"{@name}"
		
	def c
		if option(:toplevel) and option(:export)
			if STACK.cjs
				return "exports.{@identifier.c} = '{@name}'"
			else
				return M('export',option(:export)) + " const {@identifier.c} = '{@name}'"
		
		return '' if option(:inClassBody) or option(:toplevel)
		let out = "'{@name}'"
		# out += '\n/*\n' + @css + '\n*/'
		return out

	# nodes # bunch of style properties and potentially nested rules
	
export class StyleBody < ListNode
	
	def visit
		let items = @nodes
		let i = 0
			
		let prevname
		for item in items when item isa StyleDeclaration
			if !item.@property.@name
				item.@property.name = prevname

			prevname = item.@property.@name

		while i < items:length
			let item = items[i]
			let res = item.traverse

			if res != item
				if res isa Array
					items.splice(i,1,*res)
					continue
			
			# has changed?
			if item == items[i]
				i++
		self

	def toJSON
		values

export class StyleDeclaration < StyleNode
	def initialize property, expr
		@property = property
		@expr = expr isa StyleExpressions ? expr : StyleExpressions.new(expr)
		self
		
	def clone name, params
		params = @expr.clone unless params
		if typeof params == 'string' or typeof params == 'number'
			params = [params]
		if !(params isa Array) and !(params isa ListNode)
			params = [params]

		StyleDeclaration.new(@property.clone(name),params)
		
	def visit stack, o
		# see if property can be expanded
		let theme = stack.theme
		let list = stack.parent
		let name = String(@property.name)
		let alias = theme.expandProperty(name)
		
		if @expr
			@expr.traverse(
				rule: o:rule
				rootRule: o:rootRule,
				decl: self,
				property: @property
			)

		if alias isa Array
			list.replace(self,alias.map do clone($1))
			return
		elif alias and alias != name
			@property = @property.clone(alias)

		let method = helpers.symbolize(alias or name)
		
		@expr.traverse(decl: self, property: @property) if @expr

		if theme[method] and !option(:plain)
			let res = theme[method].apply(theme,@expr.toArray)
			let expanded = []
			
			if res isa Array
				@expr = StyleExpressions.new(res)
			elif res isa Object
				# console.log 'theme has method',method,res
				for own k,v of res
					if k.indexOf('&') >= 0
						let body = StyleBody.new([])
						let rule = StyleRuleSet.new(LIT(k),body)
						expanded.push(rule)
						for own k2,v2 of v
							# need recursive thing here
							body.add(clone(k2,v2))
					else
						expanded.push clone(k,v).set(plain: k == name)
				list.replace(self,expanded)
				return
			
		@expr.traverse(decl: self, property: @property) if @expr
		
		if o:styles
			let key = @property.toKey
			let val = @expr
			if o:selector
				key = JSON.stringify([o:selector,key])
				
			if @property.isUnit
				if @property.number != 1
					val = LIT("calc({val.c} / {@property.number})")

			o:styles[key] = val.c(property: @property)
		self
		
	def toCSS
		"{@property.c}: {AST.cary(@expr).join(' ')}"
		
	def toJSON
		toCSS


export class StyleProperty < StyleNode

	prop name
	prop number
	prop unit
	# modifiers
	# values
	def initialize token
		@token = token
		# also split 
		@parts = String(@token).replace(/(^|\b)\$/g,'--').split(/\b(?=[\.\@])/g) # .split(/[\.\@]/g)
		
		for part,i in @parts
			@parts[i] = part.replace(/^\./,'@.')
			
		# @parts = String(@token).replace(/(^|\b)\$/g,'--').split(/[\.\@]/g)
		@name  = String(@parts[0])
		
		if let m = @name.match(/^(\d+)([a-zA-Z]+)$/)
			@number = parseInt(m[1])
			@unit = m[2]
			
		if !@name.match(/^[\w\-]/)
			@parts.unshift(@name = null)

		self
	
	def name= value
		if let m = value.match(/^(\d+)([a-zA-Z]+)$/)
			@number = parseInt(m[1])
			@unit = m[2]
		else
			@number = @unit = null
		@name = value

	def name
		@name ||= String(@parts[0])

	def clone newname
		StyleProperty.new([newname or name].concat(modifiers).join(""))

	def addModifier modifier
		@parts.push(modifier)
		self
		
	def isUnit
		@unit

	def modifiers
		@parts.slice(1)

	def toJSON
		name + modifiers.join("Â§")

	def toString
		name + modifiers.join("Â§")
		
	def toKey
		let name = isUnit ? "--u_{@unit}" : self.name
		[name].concat(modifiers).join('Â§')
		# @parts.join('.')

	def c
		toString

	# lookup shorthand. If shorthand represents multiple
	# props then we compile it to multiple props

export class StylePropertyIdentifier < StyleNode
	def initialize name
		@name = name
		if String(name)[0] == '$'
			@name = "--{String(name).slice(1)}"
		# val[0] == '$' ? "var(--{val.slice(1)})" : val

	def toJSON
		String(@name)
		
	def toString
		String(@name)

export class StylePropertyModifier < StyleNode
	def initialize name
		@name = name
		
	def toJSON
		String(@name)
		
	def toString
		String(@name)

export class StyleExpressions < ListNode
	
	def load list
		if list isa Array
			list = list.map do $1 isa StyleExpression ? $1 : StyleExpression.new($1)
		[].concat(list)

	def c
		AST.cary(@nodes).join(', ')
		
	def clone
		StyleExpressions.new(@nodes.slice(0))
	
	def toArray
		@nodes.filter(do $1 isa StyleExpression).map(do $1.toArray )

export class StyleExpression < ListNode

	def load list
		[].concat(list)

	def toString
		AST.cary(@nodes).join(' ')
		
	def toArray
		@nodes.slice(0)
		
	def clone
		StyleExpression.new(@nodes.slice(0))
		
	def c
		toString
		
	def toJSON
		toString
		
	def toArray
		@nodes
		
	def toIterable
		@nodes
		
	def addParam param,op
		param.@op = op
		last.addParam(param)
		return self

	def reclaimParams
		let items = filter do $1:param
		for item in items
			let param = item:param
			let op = param.@op
			add([op,param],after: item)
			item.@params = []

		return

	def visit stack, o
		if o and o:property
			let name = o:property.@name

			if name == 'gt' or name == 'grid-template'
				reclaimParams
		super
		
	def visit2
		let items = @nodes
		let i = 0

		while i < items:length
			let item = items[i]
			let next = items[i + 1] # no whitespace
			let res = item.traverse
			
			if res != item
				if res isa Array
					items.splice(i,1,*res)
					continue
			
			# has changed?
			if item == items[i]
				i++
		self

export class StyleTerm < ValueNode
	

	def valueOf
		String(@value)
		
	def toString
		String(@value)
		
	def toRaw
		valueOf
		
	def toAlpha
		toString

	def visit stack, o
		@token = @value
		@property = o:property
		@propname = o:property and o:property.@name
		self:alone = stack.up.values:length == 1
		let resolved = stack.theme.$value(self,0,@propname)
		@resolvedValue = resolved unless stack.up(StyleFunction)
		self
	
	get param
		@params and @params[0]
		
	def kind
		@kind
	
	def addParam param
		@params ||= []
		@params.push(param)
		return self
		
	def c
		let out = (@resolvedValue and !(@resolvedValue isa Node)) ? C(@resolvedValue) : valueOf
		out
	
export class StyleInterpolationExpression < StyleTerm
	
	prop name
	
	def visit stack,o
		super
		if o:rootRule
			o:rootRule.addPlaceholder(self)
		@id = "{sourceId}{oid}"
		@name = "--{@id}"
		
		# @propname = stack.theme.expandProperty

	def c
		"var(--{@id})"

export class StyleFunction < Node

	def kind
		'function'

	def initialize value, params
		@name = value
		@params = params
	
	def visit stack, o
		@params.traverse if @params and @params:traverse
		self
		
	def toString
		c
		
	def c
		"{String(@name)}({@params.c})"

export class StyleIdentifier < StyleTerm
	prop color

	def visit stack
		if let c = stack.theme.$color(toString)
			color = self:param ? c.alpha(self:param.toAlpha) : c
		
		super
		
	
	def c
		return color.toString if color
		let val = toString
		val[0] == '$' ? "var(--{val.slice(1)})" : super

export class StyleString < StyleTerm

export class StyleColor < StyleTerm

export class StyleVar < StyleTerm

	def c
		toString
		# "var(--{toString})"

var VALID_CSS_UNITS = 'cm mm Q in pc pt px em ex ch rem vw vh vmin vmax % s ms fr deg rad grad turn Hz kHz'.split(' ')

export class StyleDimension < StyleTerm
	
	prop unit
	prop number

	def initialize value
		@value = value
		let m = String(value).match(/^([\-\+]?[\d\.]*)([a-zA-Z]+|%)?$/)
		@number = parseFloat(m[1])
		@unit = m[2] or null
		
	def clone num = @number, unit = @unit
		let cloned = StyleDimension.new(value)
		cloned.@unit =  unit
		cloned.@number = num
		return cloned
		
	def toString
		"{@number}{@unit or ''}"
	
	def toRaw
		@unit ? toString : @number
		
	def valueOf
		if unit == 'u'
			return number * 4 + 'px'
		elif unit == null
			return number
		elif unit in VALID_CSS_UNITS
			return String(@value)
		else
			return "calc(var(--u_{unit},{String(@value)}) * {@number})"
			# return String(@value)
			
	def toAlpha
		unless unit
			return number + '%'
		else
			return valueOf

export class StyleNumber < StyleDimension
	# prop unit
	# prop number
	# def initialize value,unit
	# 	super
	# 	@number = parseFloat(String(value))
	# 	@unit = null
		
	# def valueOf
	# 	if unit == 'u'
	# 		return number * 4 + 'px'
	# 	return String(@value)
		
	# def valueOf
	# 	number

# UTILS

export class Util < Node

	prop args

	def initialize args
		@args = args

	# this is how we deal with it now
	def self.extend a,b
		Util.Extend.new([a,b])

	def self.callImba scope, meth, args
		CALL(OP('.',scope.imba,Identifier.new(meth)),args)

	def self.repeat str, times
		var res = ''
		while times > 0
			if times % 2 == 1
				res += str
			str += str
			times >>= 1
		return res


	def self.keys obj
		var l = Const.new("Object")
		var r = Identifier.new("keys")
		CALL(OP('.',l,r),[obj])

	def self.len obj, cache
		var r = Identifier.new("length")
		var node = OP('.', obj, r)
		node.cache(force: yes, pool: 'len') if cache
		return node

	def self.indexOf lft, rgt
		var node = Util.IndexOf.new([lft,rgt])
		# node.cache(force: yes, type: 'iter') if cache
		return node

	def self.slice obj, a, b
		var slice = Identifier.new("slice")
		console.log "slice {a} {b}"
		return CALL(OP('.',obj,slice),AST.compact([a,b]))

	def self.iterable obj, cache
		return obj if STACK.tsc
		var node = Util.Iterable.new([obj])
		node.cache(force: yes, pool: 'iter') if cache
		return node

	def self.counter start, cache
		# should it not rather be a variable?!?
		var node = Num.new(start) # make sure it really is a number
		node.cache(force: yes, pool: 'counter') if cache
		return node

	def self.array size, cache
		var node = Util.Array.new([size])
		node.cache(force: yes, pool: 'list') if cache
		return node

	def inlineHelpers
		!!OPTS:inlineHelpers

	def name
		'requireDefault$'

	def js
		scope__.root.helper(self,helper)
		"{name}({@args.map(|v| v.c).join(',')})"


var HELPERS = {
	setField: '''(target,key,value,o){
		Object.defineProperty(target,key,{value:value});
	};'''
	
	unit: '''(value,unit){
		return value + unit;
	};'''
	
	cssConv: '''(value,unit,key){
		let t = typeof value;
		// Support custom units
		return value;
		// Object.defineProperty(target,key,{value:value});
	};'''

	extendTag: '''(el,cls){
		Object.defineProperties(el,Object.getOwnPropertyDescriptors(cls.prototype));
		return el;
	};'''

	initField: '''(target,key,o){
		Object.defineProperty(target,key,o);
	};'''

	decorate: '''(decorators,target,key,desc){
		var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		return c > 3 && r && Object.defineProperty(target, key, r), r;
	};'''
	
	contains: '''(a,b){
		var res = (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		return res >= 0;
	};'''
	
	requireDefault: '''(obj){
		return obj && obj.__esModule ? obj : { default: obj };
	};'''
}

export class Util.Helper < Util
	def name
		option(:name)

	def helper
		option(:helper)

for own k,v of HELPERS
	Util[k] = do |*args|
		let helper = 'function ' + k + '$' + v
		Util.Helper.new(args).set(name: k + '$', helper: helper)


export class Util.Extend < Util
	def helper
		'''
		function extend$(target,ext){
			// @ts-ignore
			var descriptors = Object.getOwnPropertyDescriptors(ext);
			// @ts-ignore
			Object.defineProperties(target.prototype,descriptors);
			return target;
		};
		'''

	def js o
		# When this is triggered, we need to add it to the top of file?
		scope__.root.helper(self,helper)
		"extend$({AST.compact(AST.cary(args)).join(',')})"

export class Util.IndexOf < Util

	def helper
		'''
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		'''

	def js o
		if inlineHelpers
			scope__.root.helper(self,helper)
			# When this is triggered, we need to add it to the top of file?
			"idx$({args.map(|v| v.c ).join(',')})"
		else
			"{scope__.imba.c}.indexOf({args.map(|v| v.c ).join(',')})"

export class Util.Promisify < Util

	def helper
		# should also check if it is a real promise
		'''
		function promise$(a){
			if(a instanceof Array){
				console.warn("await (Array) is deprecated - use await Promise.all(Array)");
				return Promise.all(a);
			} else {
				return (a && a.then ? a : Promise.resolve(a));
			}
		}
		'''

	def js o
		if inlineHelpers
			# When this is triggered, we need to add it to the top of file?
			scope__.root.helper(self,helper)
			"promise$({args.map(|v| v.c).join(',')})"
		else
			"{scope__.imba.c}.await({args.map(|v| v.c).join(',')})"

export class Util.Iterable < Util

	def helper
		# now we want to allow null values as well - just return as empty collection
		# should be the same for for own of I guess
		"function iter$(a)\{ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : []; \};"

	def js o
		return args[0].c if args[0] isa Arr # or if we know for sure that it is an array
		scope__.root.helper(self,helper)
		return "iter$({args[0].c})"

export class Util.IsFunction < Util

	def js o
		"{args[0].c}"

export class Util.Array < Util

	def js o
		# When this is triggered, we need to add it to the top of file?
		"new Array({args.map(|v| v.c)})"

class Entities

	def initialize root
		@root = root
		@map = []
		return self

	def add path, object
		@map[path] = object
		unless @map.indexOf(object) >= 0
			@map.push(object)
		self

	def lookup path
		@map[path]

	# def register entity
	# 	var path = entity.namepath
	# 	@map[path] ||= entity
	# 	self

	def plain
		JSON.parse(JSON.stringify(@map))

	def toJSON
		@map

class RootEntities
	
	def initialize root
		@root = root
		@map = {}
		return self

	def add path, object
		@map[path] = object
		self

	def register entity
		var path = entity.namepath
		@map[path] ||= entity
		self

	def plain
		JSON.parse(JSON.stringify(@map))

	def toJSON
		@map
	
# SCOPES

# handles local variables, self etc. Should create references to outer scopes
# when needed etc.

# add class for annotations / registering methods, etc?
# class Interface

# should move the whole context-thingie right into scope
export class Scope

	prop level
	prop context
	prop node
	prop parent
	prop varmap
	prop varpool
	prop params
	prop head
	prop vars
	prop counter
	prop entities

	def p
		if STACK.loglevel > 0
			console.log(*arguments)
		self
	
	def oid
		@oid ||= STACK.generateId('')

	def stack
		STACK
		
	def kind
		@kind ||= self:constructor:name.replace('Scope','').toLowerCase()

	def initialize node, parent
		@nr = STACK.incr('scopes')
		@head = []
		@node = node
		@parent = parent
		@vars = ScopeVariables.new([])
		@entities = Entities.new(self)
		@meta = {}
		@annotations = []
		@closure = self
		@virtual = no
		@counter = 0
		@varmap  = {}
		@counters = {}
		@varpool = []
		@refcounter = 0
		@level = (parent ? parent.@level : -1) + 1
		setup
		
	def setup
		@selfless = yes
		
	def incr name = 'i'
		var val = @counters[name] ||= 0
		@counters[name]++
		return val

	def nextShortRef
		AST.counterToShortRef(@refcounter++)

	def memovar name, init
		@memovars ||= {}
		let item = @memovars[name]
		unless item
			item = @memovars[name] = declare(item,init)
			# temporary(null,{reuse: yes},"{name}")
			
		return item
	
	# def cssMixinFlag name
		

	def meta key, value
		if value != undefined
			@meta[key] = value
			return self
		@meta[key]

	def namepath
		'?'
		
	def tagCache
		# deal with root instead?
		@tagCache ||= declare('c$$',
			# LIT('(Imba.$c ? (Imba.$c[Imba.$k] || (Imba.$c[Imba.$k] = {})) : {})'),
			LIT('(imba.ctx||{})'),
			system: yes
			temporary: yes
		)
	# def context
	# 	@context ||= ScopeContext.new(self)
		
	def context
		# why do we need to make sure it is referenced?
		unless @context
			if selfless
				@context = parent.context.fromScope(self)
				# @context.reference(self)
			else
				@context = ScopeContext.new(self)
		return @context

	def traverse
		self

	def visit
		return self if @parent
		@parent = STACK.scope(1) # the parent scope
		@level = STACK.scopes:length - 1

		STACK.addScope(self)
		root.scopes.push(self)
		self

	def wrap scope
		@parent = scope.@parent
		scope.@parent = self
		self

	# called for scopes that are not real scopes in js
	# must ensure that the local variables inside of the scopes do not
	# collide with variables in outer scopes -- rename if needed
	def virtualize
		self

	def root
		return STACK.ROOT

		var scope = self
		while scope
			return scope if scope isa RootScope
			scope = scope.parent
		return null

	def register name, decl = null, o = {}
		# FIXME re-registering a variable should really return the existing one
		# Again, here we should not really have to deal with system-generated vars
		# But again, it is important

		if !name
			o:system = yes

		if o:system
			return (o:varclass or SystemVariable).new(self,name,decl,o)

		name = helpers.symbolize(name)

		# also look at outer scopes if this is not closed?
		var existing = @varmap.hasOwnProperty(name) && @varmap[name]
		
		if existing
			if decl and existing.type != 'global'
				decl.warn('Cannot redeclare variable')
			# console.log 'redeclaring variable',"{existing} {decl}",existing.type
			
		# FIXME check if existing is required to be unique as well?
		if existing and !o:unique
			return existing
		
		let par = o:lookup && parent && parent.lookup(name)
		
			

		# var type = o:system ? SystemVariable : Variable
		var item = (o:varclass or Variable).new(self,name,decl,o)
		
		if par
			item.@parent = par
		
		if !o:system and !existing
			@varmap[name] = item

		if STACK.state and STACK.state:variables isa Array
			STACK.state:variables.push(item)
		return item

	def annotate obj
		@annotations.push(obj)
		self

	# just like register, but we automatically
	def declare name, init = null, o = {}
		var variable = name isa Variable ? name : register(name,null,o)
		# TODO create the variabledeclaration here instead?
		# if this is a sysvar we need it to be renameable
		var dec = @vars.add(variable,init)
		variable.declarator ||= dec
		return variable

	
	def reusevar name
		temporary(null,{reuse: yes},name)

	# what are the differences here? omj
	# we only need a temporary thing with defaults -- that is all
	# change these values, no?
	def temporary decl, o = {}, name = null
		if @systemscope and @systemscope != self
			return @systemscope.temporary(decl,o,name)

		name ||= o:name
		o:temporary = yes
		if name and o:reuse and @vars["_temp_{name}"]
			return @vars["_temp_{name}"]

		if o:pool
			for v in @varpool
				if v.pool == o:pool && v.declarator == null
					return v.reuse(decl)

		var item = SystemVariable.new(self,name,decl,o)
		
		@varpool.push(item) # It should not be in the pool unless explicitly put there?
		@vars.push(item) # WARN variables should not go directly into a declaration-list
		if name and o:reuse
			@vars["_temp_{name}"] = item
		return item

	def lookup name
		@lookups ||= {}
		var ret = null
		name = helpers.symbolize(name)
		if @varmap.hasOwnProperty(name)
			ret = @varmap[name]
		else
			ret = parent && parent.lookup(name)

			if ret
				@nonlocals ||= {}
				@nonlocals[name] = ret
		ret

	def requires path, name = ''
		root.requires(path,name)

	def imba
		@imba ||= (STACK.isNode ? LIT("(this && this[{root.symbolRef('#imba').c}] || globalThis[{root.symbolRef('#imba').c}])") : LIT('imba'))
		# root.imba # requires('imba2', 'Imba')

	def imbaTags
		root.imbaTags
		
	def imbaRef name, shorthand = '_'
		root.imbaRef(name,shorthand)

	def imbaDependency *params
		root.imbaDependency(*params)

	def autodeclare variable
		vars.push(variable) # only if it does not exist here!!!

	def free variable
		variable.free # :owner = null
		# @varpool.push(variable)
		self

	def selfless
		!!@selfless

	def closure
		@closure

	def finalize
		self

	def klass
		var scope = self
		while scope
			scope = scope.parent
			return scope if scope isa ClassScope
		return null

	def head
		[@vars,@params]

	def c o = {}
		o:expression = no
		# need to fix this
		node.body.head = head
		var body = node.body.c(o)

	def region
		node.body.region

	def loc
		node.loc

	def dump
		var vars = Object.keys(@varmap).map do |k|
			var v = @varmap[k]
			# unless v.@declarator isa Scope
			# 	console.log v.name, v.@declarator:constructor:name
			# AST.dump(v)
			v.references:length ? AST.dump(v) : null

		var desc =
			nr: @nr
			type: self:constructor:name
			level: (level or 0)
			vars: AST.compact(vars)
			loc: loc

		return desc

	def toJSON
		dump

	def toString
		"{self:constructor:name}"

	def closeScope
		self


# RootScope is wrong? Rather TopScope or ProgramScope
export class RootScope < Scope

	prop warnings
	prop scopes
	prop entities
	prop object
	prop styles
	prop options
	prop assets
	prop document

	

	def initialize
		super

		register('global', self, type: 'global').@c = 'globalThis'

		register 'module', self, type: 'global'
		register 'imba', self, type: 'global', varclass: GlobalReference
		register 'window', self, type: 'global', varclass: GlobalReference
		self.document = register 'document', self, type: 'global', varclass: GlobalReference
		register 'exports', self, type: 'global'
		register 'console', self, type: 'global'
		register 'process', self, type: 'global'
		register 'parseInt', self, type: 'global'
		register 'parseFloat', self, type: 'global'
		register 'setTimeout', self, type: 'global'
		register 'setInterval', self, type: 'global'
		register 'setImmediate', self, type: 'global'
		register 'clearTimeout', self, type: 'global'
		register 'clearInterval', self, type: 'global'
		register 'clearImmediate', self, type: 'global'
		register 'globalThis', self, type: 'global'
		register 'isNaN', self, type: 'global'
		register 'isFinite', self, type: 'global'
		register '__dirname', self, type: 'global'
		register '__filename', self, type: 'global'
		register '_', self, type: 'global'

		# preregister global special variables here
		@requires = {}
		@warnings = []
		@scopes   = []
		@helpers  = []
		@styles = []
		@assets = {}
		@selfless = yes
		@implicitAccessors = []
		@entities = RootEntities.new(self)
		@object = Obj.wrap({})
		@head = [@vars]
		@dependencies = {}
		@symbolRefs = {}
		@vars.split = yes
		self

	def sourceId
		@sourceId ||= @options:sourcePath and helpers.identifierForPath(@options:sourcePath)
	# single-file-component options
	def sfco
		@sfco ||= declare('sfc$',LIT('{/*$sfc$*/}'))

	def context
		@context ||= RootScopeContext.new(self)

	def globalRef
		@globalRef ||= LIT('globalThis')
		
	def activateExports
		if STACK.cjs and !@hasExports
			@hasExports = yes
			@head.push(LIT('Object.defineProperty(exports, "__esModule", {value: true});'))
	
	def lookupAsset name
		unless @assets[name]
			let asset = STACK.getAsset(name)
			registerAsset(name,asset)
		return @assets[name]

	def registerAsset name, asset
		@assets[name] = asset

	def lookup name
		name = helpers.symbolize(name)
		@varmap[name] if @varmap.hasOwnProperty(name)

	def visit
		STACK.addScope(self)
		self

	def helper typ, value
		# log "add helper",typ,value
		if @helpers.indexOf(value) == -1
			@helpers.push(value)
			@head.unshift(value)

		return self

	def head
		@head

	def warn data
		# hacky
		data:node = null
		@warnings.push(data)
		self

	def dump
		var obj = {
			warnings: AST.dump(@warnings)
			autoself: @implicitAccessors.map(|s| s.dump)
		}

		if OPTS:analysis:scopes
			var scopes = @scopes.map(|s| s.dump)
			scopes.unshift(super.dump)
			obj:scopes = scopes

		if OPTS:analysis:entities
			obj:entities = @entities

		return obj

	

	# not yet used
	def requires path, name
		if var variable = lookup(name)
			return variable

		if var variable = @requires[name]
			if variable.@requirePath != path
				throw Error.new("{name} is already defined as require('{variable.@requirePath}')")
			return variable

		var req = Require.new(Str.new("'" + path + "'"))
		var variable = Variable.new(self,name,null,system: yes)
		var dec = @vars.add(variable, req)
		variable.declarator ||= dec
		variable.@requirePath = path
		@requires[name] = variable
		return variable

	def imba
		LIT('imba')

	def imbaTags
		return @imbaTags if @imbaTags
		var imbaRef = self.imba
		# don't add if we cannot be certain that imba is required on top
		if @requires.Imba
			@imbaTags = declare('_T',OP('.',imbaRef,'TAGS'))
		else
			@imbaTags = "{imbaRef.c}.TAGS"

	def imbaDependency path
		return if OPTS:imbaPath === null or OPTS:standalone or (OPTS:target == 'tsc' or OPTS:tsc)
		return if OPTS:imbaFormat == 'script' or OPTS:runtime == 'global'
		@dependencies[path] ||= if true
			let str = "'{OPTS:imbaPath or 'imba'}/src/imba/{path}'"
			let item = STACK.cjs ? LIT("require({str})") : LIT("import {str}")
			@head.push(item)
			item
			
	def imbaRef name, shorthand = '_'
		if name == 'tagscope'
			name = 'createTagScope(/*SCOPEID*/)'
		elif name == 'tagfactory'
			name = 'createElementFactory(/*SCOPEID*/)'

		var map = @imbaRefs ||= {}
		return map[name] if map[name]

		var imbaRef = self.imba
		
		if @requires.Imba
			map[name] = declare(shorthand,OP('.',imba,name), system: yes)
		else
			map[name] = "{imbaRef.c}.{name}"

	def symbolRef name
		let map = @symbolRefs
		map[name] ||= declare("{String(name).replace(/[\@\#]/g,'_')}$",LIT("Symbol.for('{name}')"), type: 'const', system: yes)
		

	def c o = {}
		o:expression = no

		let body = node.body.c(o)
		let assetCount = Object.keys(assets):length

		if assetCount
			head.push LIT('// ASSETS-START')

		for own name, asset of assets
			try
				let parsed = parseAsset(asset,name)
				let body = JSON.stringify(parsed)
				let out = "imba.registerAsset('{name}',{body})"
				head.push LIT(out)

		if assetCount
			head.push LIT('// ASSETS-END')

		let pre = Block.new([])
		pre.head = head
				
		return pre.c(o) + '\n' + body

export class ModuleScope < Scope

	def setup
		@selfless = no

	def namepath
		@node.namepath

export class ClassScope < Scope
	
	def setup
		@selfless = no

	def namepath
		@node.namepath

	# called for scopes that are not real scopes in js
	# must ensure that the local variables inside of the scopes do not
	# collide with variables in outer scopes -- rename if needed
	def virtualize
		# console.log "virtualizing ClassScope"
		var up = parent
		for own k,v of @varmap
			v.resolve(up,yes) # force new resolve
		self
		
	def prototype
		@prototype ||= ValueNode.new(OP('.',context,'prototype'))

export class TagScope < ClassScope

export class ClosureScope < Scope

export class FunctionScope < Scope

export class IsolatedFunctionScope < FunctionScope
	
	def lookup name
		@lookups ||= {}
		var ret = null
		name = helpers.symbolize(name)
		if @varmap.hasOwnProperty(name)
			ret = @varmap[name]
		else
			ret = parent && parent.lookup(name)
			
			# only shadow variables inside the same closure?
			if ret and ret.closure == parent.closure
				@leaks ||= Map.new
				@nonlocals ||= {}
				@nonlocals[name] = ret
				
				let shadow = @leaks.get(ret)
				unless shadow
					@leaks.set(ret,shadow = ShadowedVariable.new(self,name,ret))
				ret = shadow
		ret


export class MethodScope < Scope

	def setup
		@selfless = no

export class FieldScope < Scope
	
	def setup
		@selfless = no
		
	def mergeScopeInto other
		for own k,v of @varmap
			continue if k == 'self'
			v.resolve(other,yes)
			other.declare(v)
		
		if @context and @context.@reference
			@context.@reference = other.context.reference
		yes


export class LambdaScope < Scope

	def context
		# why do we need to make sure it is referenced?
		unless @context
			@context = parent.context.fromScope(self)
		@context


export class FlowScope < Scope

	# these have no params themselves, refer to outer scopes -- hjmm
	def params
		@parent.params if @parent

	def register name, decl = null, o = {}
		if o:type != 'let' and (closure != self)
			if var found = lookup(name)
				if found.type == 'let'
					# p "{name} already exists as a block-variable {decl}"
					# TODO should throw error instead
					decl.warn "Variable already exists in block" if decl
					# root.warn message: "Holy shit"
			closure.register(name,decl,o)
		else
			super(name,decl,o)

	# FIXME should override temporary as well

	def autodeclare variable
		parent.autodeclare(variable)

	def closure
		@parent.closure # this is important?

	def context
		@context ||= parent.context

	def closeScope
		# FIXME
		@context.reference if @context
		self
		
	def temporary refnode, o = {}, name = null
		(@systemscope or parent).temporary(refnode,o,name)

export class CatchScope < FlowScope

export class WhileScope < FlowScope

	def autodeclare variable
		vars.push(variable)

export class ForScope < FlowScope

	def autodeclare variable
		vars.push(variable)

export class IfScope < FlowScope

export class BlockScope < FlowScope

	def region
		node.region

# lives in scope -- really a node???
export class Variable < Node

	prop scope
	prop name
	prop alias
	prop type
	prop options
	prop initialized
	prop declared
	prop declarator
	prop autodeclare
	prop references
	prop export
	prop value

	def pool
		null

	def initialize scope, name, decl, o
		@ref = STACK.@counter++
		@c = null
		@scope = scope
		@name  = name
		@alias = null
		@initialized    = yes
		@declarator  	= decl
		@autodeclare 	= no
		@declared		= o and o:declared || no
		@resolved		= no
		@options 		= o || {}
		@type			= o and o:type || 'var' # what about let here=
		@export			= no
		@references 	= [] # only needed when profiling
		@assignments 	= []
		self

	def closure
		@scope.closure

	def assignments
		@assignments

	# Here we can collect lots of type-info about variables
	# and show warnings / give advice if variables are ambiguous etc
	def assigned val, source
		@assignments.push(val)
		if val isa Arr
			# just for testing really
			@isArray = yes
		else
			@isArray = no
		self
	
	def parents
		let parents = []
		let scope = closure.parent
		let res = self
		while scope and res and parents:length < 5
			console.log 'get parents!!!'
			if res = scope.lookup(@name)
				parents.unshift(res)
				let newscope = res.scope.parent
				if scope == newscope
					break
				scope = newscope

		return parents

	def resolve scope = scope, force = no
		return self if @resolved and !force
		

		@resolved = yes
		var closure = @scope.closure
		var item = @shadowing or scope.lookup(@name)
		
		# console.log "resolving var {@name} {scope}",scope == @closure,@virtual

		# if this is a let-definition inside a virtual scope we do need
		#
		if @scope != closure and @type == 'let' and @virtual # or if it is a system-variable
			item = closure.lookup(@name)
			# console.log "resolving let {@name} {item.scope != scope}"
			# we now need to ensure that this variable is unique inside
			# the whole closure.
			scope = closure

		if item == self
			scope.varmap[@name] = self
			return self

		elif item
			# possibly redefine this inside, use it only in this scope
			# if the item is defined in an outer scope - we reserve the
			if item.scope != scope && (options:let or @type == 'let')
				scope.varmap[@name] = self
				# if we allow native let we dont need to rewrite scope?
				return self if (!@virtual and !@shadowing)
					

			# different rules for different variables?
			if @options:proxy
				yes
			else
				var i = 0
				var orig = @name
				# it is the closure that we should use
				while scope.lookup(@name)
					@name = "{orig}{i += 1}"

		scope.varmap[@name] = self
		closure.varmap[@name] = self
		return self

	def reference
		self

	def node
		self

	def cache
		self

	def traverse
		self

	def free ref
		@declarator = null
		self

	def reuse ref
		@declarator = ref
		self

	def proxy par, index
		@proxy = [par,index]
		self

	def refcount
		@references:length

	def c
		return @c if @c
		# options - proxy??
		if @proxy
			if @proxy isa Node
				@c = @proxy.c
			else
				@c = @proxy[0].c
				if @proxy[1]
					@c += '[' + @proxy[1].c + ']'
		else
			resolve unless @resolved
			var v = (alias or name)
			@c = typeof v == 'string' ? v : v.c
			# allow certain reserved words
			# should warn on others though (!!!)
			# if @c == 'new'
			# 	@c = '_new'
			# 	# should happen at earlier stage to
			# 	# get around naming conventions
			@c = "{c}$" if RESERVED_REGEX.test(@c) # @c.match(/^(default)$/)
			# @c = @c + '/*' + @ref + '*/'
		return @c

	def js
		self.c()

	# variables should probably inherit from node(!)
	def consume node
		return self

	# this should only generate the accessors - not dael with references
	def accessor ref
		var node = LocalVarAccess.new(".",null,self)
		# this is just wrong .. should not be a regular accessor
		# @references.push([ref,el]) if ref # weird temp format
		return node

	def assignment val
		Assign.new('=',self,val)

	def addReference ref
		if ref isa Identifier
			ref.references(self)

		if ref:region and ref.region
			@references.push(ref)
			if ref.scope__ != @scope
				@noproxy = yes

		self

	def autodeclare
		return self if @declared
		@autodeclare = yes
		scope.autodeclare(self)
		@declared = yes
		self

	def predeclared
		@declared = yes
		self


	def toString
		String(name)

	def dump typ
		var name = name
		return null if name[0].match(/[A-Z]/)

		return {
			type: type
			name: name
			refs: AST.dump(@references, typ)
		}


export class SystemVariable < Variable

	def pool
		@options:pool

	# weird name for this
	def predeclared
		scope.vars.remove(self)
		self

	def resolve
		return self if @resolved
		@resolved = yes

		# unless @name
		# adds a very random initial name
		# the auto-magical goes last, or at least, possibly reuse other names
		# "${Math.floor(Math.random * 1000)}"
		let o = @options
		var alias = o:alias or @name
		var typ = o:pool
		var names = [].concat(o:names)
		var alt = null
		var node = null

		@name = null

		var scope = self.scope
		
		if o:temporary and !o:alias
			let i = 0
			@name = '$' + i
			while scope.lookup(@name)
				@name = "${i += 1}"

		if typ == 'tag'
			let i = 0
			while !@name
				var alt = "t{i++}"
				@name = alt unless scope.lookup(alt)

		elif typ == 'iter'
			names = ['ary__','ary_','coll','array','items','ary']

		elif typ == 'dict'
			names = ['dict']

		elif typ == 'val'
			names = ['v_']

		elif typ == 'arguments'
			names = ['$_','$0']

		elif typ == 'keypars'
			names = ['opts','options','pars']

		elif typ == 'counter'
			names = ['i__','i_','k','j','i']

		elif typ == 'len'
			names = ['len__','len_','len']

		elif typ == 'list'
			names = ['tmplist_','tmplist','tmp']
		# or if type placeholder / cacher (add 0)

		if alias
			names.push(alias)

		while !@name && alt = names.pop
			let foundAlt = scope.lookup('$' + alt)
			# check if higher level?
			if !foundAlt # or (foundAlt.scope != scope and type == 'let')
				@name = '$' + alt # unless scope.lookup(alt)

		if !@name and @declarator
			if node = declarator.node
				if var nodealias = node.alias
					names.push(nodealias)

		while !@name && alt = names.pop
			@name = '$' + alt unless scope.lookup('$' + alt)

		# go through alias proxies
		if !@name
			let i = 0
			@name = '$' + (alias or '') + i
			# it is the closure that we should use
			# 
			while scope.lookup(@name)
				@name = "${alias or ''}{i += 1}"

		scope.varmap[@name] = self

		if type != 'let' or @virtual
			closure.varmap[@name] = self
		self

	def name
		resolve
		@name

export class ShadowedVariable < Variable


export class GlobalReference < Variable
	def c2 o
		if STACK.platform == 'node' and !@c
			if @name == 'window' or @name == 'document'
				@c = "(this[{symbolRef('#imba').c}] || globalThis.imba).{@name}"
			# if @name == 'document'
			#	@scope.@head.push("const $imbadoc$ = (imba.document || (imba.document = new imba.dom.Document))")
			#	@c = '$imbadoc$'
			if @name == 'imba'
				# if accessed directly it should just reference global.imba for speed?
				@c = "(this[{symbolRef('#imba').c}] || globalThis.imba)"
			elif @name == 'window' or @name == 'document'
				@c = "(this[{symbolRef('#imba').c}] || globalThis.imba).{@name}"
		super

export class GlobalDocumentReference < Variable
	def c
		if STACK.platform == 'node' and !@c
			@scope.@head.push("const $imbadoc$ = (imba.document || (imba.document = new imba.dom.Document))")
			@c = '$imbadoc$'

		super

export class ScopeContext < Node

	prop scope
	prop value
	prop reference

	def initialize scope, value
		@scope = scope
		@value = value
		@reference = null
		self

	def namepath
		@scope.namepath

	# instead of all these references we should probably
	# just register when it is accessed / looked up from
	# a deeper function-scope, and when it is, we should
	# register the variable in scope, and then start to
	# use that for further references. Might clean things
	# up for the cases where we have yet to decide the
	# name of the variable etc?

	def reference
		# if we are in  constructor we do want to declare it after super
		@reference ||= scope.declare("self",This.new) # {@scope.@level}_

	def fromScope other
		IndirectScopeContext.new(other,self)

	def c
		var val = @value # || @reference
		(val ? val.c : "this")

	def cache
		self
		
	def proto
		"{self.c}.prototype"
		
	def isGlobalContext
		no

export class IndirectScopeContext < ScopeContext
	
	def initialize scope, parent
		@scope = scope
		@parent = parent
		@reference = parent.reference

	def reference
		@reference # parent.reference

	def c
		reference.c
		
	def isGlobalContext
		@parent.isGlobalContext

export class RootScopeContext < ScopeContext

	def reference
		# should be a 
		@reference ||= scope.lookup('global') # declare("self",scope.object, type: 'global')

	def c o
		# @reference ||= scope.declare("self",scope.object, type: 'global')
		# return "" if o and o:explicit
		return "globalThis"
		var val = reference # @value || @reference
		return (val and val != this) ? val.c : "this"
		# should be the other way around, no?
		# o and o:explicit ? super : ""
	
	def isGlobalContext
		yes

export class Super < Node
	def initialize keyword
		@keyword = keyword
		super

	def visit
		@method = STACK.method
		@up = STACK.parent
		if var m = STACK.method
			m.set(supr: {node: STACK.blockpart, block: STACK.block})
			m.set(injectInitAfter: STACK.blockpart)
		self

	def startLoc
		@keyword and @keyword.startLoc

	def endLoc
		@keyword and @keyword.endLoc

	def c
		let m = @method
		let up = @up
		let sup = LIT('super')
		let op
		let virtual = m and m.option('inExtension')
		# need to know if our method is in the initial declaration

		# when super is written all by itself - it means to do the default action
		unless (up isa Access) or (up isa Call)
			if m and m.isConstructor
				op = LIT('super(...arguments)')
			elif m and virtual
				op = CALL(OP('.',slf,'super$'),[m.name.toStr])
				if m.isSetter
					op = CALL(OP('.',slf,'super$set'),[m.name.toStr,m.params.at(0)])
				elif !m.isGetter
					op = CALL(OP('.',op,'apply'),[slf,LIT('arguments')])
			elif m
				op = OP('.',sup,m.name)
				if m.isSetter
					op = OP('=',op,m.params.at(0))
				elif !m.isGetter
					op = CALL(op,[LIT('...arguments')])

			return op ? (M op.c(mark: false), self) : '/**/'

		if up isa Call and m and !m.isConstructor
			return OP('.',sup,m.name).c

		return "super"

# constants

export var BR0 = Newline.new('\n')
export var BR = Newline.new('\n')
export var BR2 = Newline.new('\n\n')
export var SELF = Self.new
export var THIS = LIT('this')
export var PROTO = LIT('this.prototype')
# export var SUPER = Super.new

export var TRUE = True.new('true')
export var FALSE = False.new('false')
export var UNDEFINED = Undefined.new
export var NIL = Nil.new

export var ARGUMENTS = ArgsReference.new('arguments')
export var EMPTY = ''
export var NULL = 'null'

export var RESERVED = ['default','native','enum','with']
export var RESERVED_REGEX = /^(default|native|enum|with|new|char)$/










